\documentclass{article}


\begin{document}
	
	\title{Mesterséges Intelligencia}
	\author{Vass Miklós Szilveszter}
	
	\section{AZ MI FOGALMA}
	\subsection{Miről ismerhető fel az MI?}
	\underline{Megoldandó feladat:} nehéz\\
	- A feladat problématere hatalmas\\	
	-Szisztematikus keresés helyett intuícióra, kreativitásra (azaz heurisztikára) van szükségünk ahhoz, hogy elkerljük a kombinatorikus robbanást.\\
	\underline{Szoftver viselkedése:} intelligens (tárol ismeretet, automatikusan következtet, tanul, gépi látás, gépi cselekvés)\\
	-Turing teszt vs. kínai szoba elmélet\\
	-"mesterjelölt szintű" mesterséges intelligencia\\
	\underline{Felhasznált eszközök:} sajátosak\\
	-Átgondolt reprezentáció a feladat modellezéséhez\\
	-Heurisztikával megerősített hatékony algoritmusok\\
	-Gépi tanulás módszerei\\
	
	\section{MODELLEZÉS ÉS KERESÉS}
	feladat $\rightarrow$ útkeresési probléma $\rightarrow$ megoldás\\
	Feladat és útkeresési probléma között helyezkedik el a modellezés. Itt található az állapottér-reprezentáció, a probléma dekompozíció, a korlátprogramozási modell, és a logikai reprezentáció.\\
	Az útkeresési problémát egy gráffal reprezentálhatjuk.
	Az útkeresési probléma és a megoldás között található a keresés. A keresésbe tartoznak a lokális keresések, a visszalépéses keresések, a gráfkeresések, az evolúciós algoritmus, a rezolúció és a szabályalapú következtetés.\\
	
	\subsection{Mire kell a modellezésnek fókuszálni}
	Problématér elemei: probléma lehetséges válaszai.\\
	Cél: egy helyes válasz (megoldás) megtalálása\\
	Keresést segítő ötletek (heurisztikák): \\
	-Problématér hasznos elemeinek elválasztása a haszontalanoktól.\\
	-Az elemek szomszédsági kapcsolatainak kijelölése, hogy a probléma tér elemeinek szisztematikus bejárását segítsük.\\
	-Adott pillanatban elérhető elemek rangsorolása.\\
	-Kiinduló elem kijelölése.\\
	
	\subsection{Útkeresési probléma}
	Egy útkeresési problémában a problématér elemeit egy olyan élsúlyozott irányított gráf csúcsai vagy útjai szimbolizálják, amelyik gráf nem feltétlenül véges, de a csúcsainak kifoka véges, és van egy közös pozitív alsó korlátja az élek súlyának (költségének) ($\delta$-gráf).\\
	A megoldást ennek megfelelően vagy egy célcsúcs, vagy egy startcsúcsból célcsúcsba vezető út (esetleg a legolcsóbb ilyen) megtalálása szolgáltatja.\\
	Számos olyan modellező módszert ismerünk, amely a kitűzött feladatot útkeresési problémává fogalmazza át.
	
	\subsection{Gráf fogalmak}
	-csúcsok, irányított élek:$\rightarrow$ N, A $\subseteq$ NxN\\
	-él n-ből m-be $\rightarrow$ (n,m) $\in$ A (n,m $\in$ N)\\
	-n utódai $\rightarrow$ $\gamma$ (n) = $\{$ m $\in$ N $\mid$ (n,m) $\in$ A $\}$\\
	-n szülei $\rightarrow$ $\pi$(n) $\in$ $\Pi$(n) = $\{$ m $\in$ N $\mid$ (m,n) $\in$ A $\}$\\
	-irányított gráf $\rightarrow$ R=(N,A)\\
	-véges sok kivezető él $\rightarrow$ $\mid$ $\gamma$ (n) $\mid$ $<$ $\infty$ ($\forall$ n $\in$ N)\\
	-élköltség $\rightarrow$ c:A $\rightarrow$ ${\rm I\!R}$\\
	-$\delta$ tulajdonság ($\delta$$\in$${\rm I\!R^+}$) $\rightarrow$ c(n,m) $\geq$ $\delta$ $>$ 0 ($\forall$(n,m)$\in$A)\\
	-$\delta$-gráf $\rightarrow$ $\delta$-tulajdonságú, véges sok kivezető élű, élsúlyozott irányított gráf\\
	-irányított út $\rightarrow$ $\alpha$ = (n,$n_1$),($n_1$,$n_2$),...,(n$\textsubscript{k-1}$,m) = $<$n,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m$>$ n$\rightarrow$$\textsuperscript{$\alpha$}$m, n$\rightarrow$ m, n$\rightarrow$M (M $\subseteq$ N) {n$\rightarrow$m}, {n$\rightarrow$M}\\
	-út hossza $\rightarrow$ az út éleinek száma: $|$$\alpha$$|$\\
	-út költsége $\rightarrow$ c($\alpha$)=c$\textsuperscript{$\alpha$}$(n,m) :=  $\sigma$$\textsubscript{j=1..k}$c(n$\textsubscript{j-1}$,$n_j$) ha $\alpha$ = $<$n=$n_0$,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m=$n_k$$>$\\
	-opt. költség $\rightarrow$ c*(n,m):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,m) $\{$$\delta$ gráfokban ez végtelen sok út esetén is értelmes. Értéke $\infty$, ha nincs egy út se.$\}$ \\
	-opt. költség2 $\rightarrow$ c*(n,M):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,M) \\
	-opt. költségű út n$\rightarrow$*m :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$m$\}$ $\}$ \\
	-opt. költségű út n$\rightarrow$*M :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$M$\}$ $\}$ \\
	
	\subsection{Gráfreprezentáció fogalma}
	Minden útkeresési probléma rendelkezik egy (a probléma modellezéséből származó) gráfreprezentációval, ami egy (R,s,T) hármas, amelyben:\\
	-R=(N,A,c) $\delta$-gráf az ún. reprezentációs gráf,\\
	-az s$\in$N startcsúcs,\\
	-a T$\subseteq$N halmazbeli célcsúcsok.\\
	És a probléma megoldása:\\
	-egy t$\in$T cél megtalálása, vagy\\
	-egy s$\rightarrow$T, esetleg s$\rightarrow$*T optimális út megtalálása\\
	(s-ből Tegyik csúcsába vezető irányított út, vagy s-ből T egyik csúcsába vezető legolcsóbb irányított út)\\
	Az útkeresési problémák megoldásáshoz azok a reprezentációs gráfjainak nagy mérete miatt speciális (nem determinisztikus, heurisztikus) útkereső algoritmusokra van szükség, amelyek:\\
	-a startcsúcsból indulnak, amely az első aktuális csúcs;\\
	-minden lépésben nem-determinisztikus módon új aktuális csúcso(ka)t választanak a korábbi aktuális csúcs(ok) alapján (gyakran azok gyerekei közül);\\
	-tárolják a már feltárt reprezentációs gráf egy részét;\\
	-megállnak, ha célcsúcsot találnak vagy nyilvánvalóvá válik, hogy erre semmi esélyük.\\
	
	\subsection{Kereső rendszer (KR)}
	Procedure KR\\
	1. ADAT:= kezdeti érték\\
	2. while !terminálási feltétel(ADAT) loop\\
	3. \quad SELECT SZ FROM alkalmazható szabályok\\
	4. \quad ADAT := SZ(ADAT)\\
	5. endloop\\
	end\\
	AHOL:\\
	-ADAT: globális munkaterület, tárolja a keresés során megszerzett és megőrzött ismeretet\\
	-alkalmazható szabályok: keresési szabályok, megváltoztatják a globális munkaterület tartalmát\\
	-SELECT: vezérlési stratégia, alkalmazható szabályok közül kiválaszt egy "megfelelőt"
	
	\subsection{Kereső rendszerek vizsgálata}
	-helyes-e (azaz korrekt választ ad-e)\\
	-teljes-e (minden esetben választ ad-e)\\
	-optimális-e(optimális megoldást ad-e)\\
	-idő bonyolultság\\
	-tár bonyolultság\\
	
	\section{GÉPI TANULÁS}
	-Egy programozási feladat megoldásához meg kell adnunk a feladat modelljét és készítenünk kell egy ehhez illeszkedő algoritmust, amely a feladat megoldását előállítja.\\
	-Gépi tanulással a modell (reprezentáció és/vagy heurisztika), illetve a megoldó algoritmus (többnyire annak bizonyos paraméterei) állhatnak elő automatikusan.\\
	-A tanuláshoz a megoldandó probléma néhány konkrét esetére, a tanító példákra van szükség.\\
	-A gépi tanulási módszereket három csoportba szokás sorolni: felügyelt-, nem-felügyelt, és megerősítéses tanulásra attól függően, hogy a tanító példák input-output párok, csak inputok, vagy input-hasznosság párok.\\
	
	\section{Állapottér-reprezentáció}
	\underline{Állapottér}: a probléma leírásához szükséges adatok által felvett érték-együttesek (azaz állapotok) halmaza\\
	-az állapot többnyire egy összetett szerkezetű érték\\
	-gyakran egy bővebb alaphalmazzal és egy azon értelmezett invariáns állítással definiáljuk\\
	\underline{Múveletek}: állapotból állapotba vezetnek.\\
	-megadásukhoz: előfeltétel és hatás leírása\\
	-invariáns tulajdonságot tartó leképezés\\
	\underline{Kezdőállapot(ok)} vagy azokat leíró kezdeti feltétel\\
	\underline{Végállapot(ok)} vagy célfeltétel
	
	\subsection{Hanoi tornyai probléma}
	
	\underline{Állapottér:}
	AT=$\{$1,2,3$\}$\textsuperscript{n}\\
	megjegyzés: a tömb i-dik eleme mutatja az i-dik korong rúdjának számát, a korongok a rudakon méretük szerint fentről lefelé növekvő sorban vannak.\\	
	\underline{Művelet:}Rak(honnan,hova): AT$\rightarrow$AT honnan, hova $\in$ \{1,2,3\}\\
	HA a honnan és hova \underline{létezik} és \underline{nem azonos}, és \underline{van korong} a honnan rúdon, és a hova rúd \underline{üres} vagy a mozgatandó korong (honnan rúd felső korongja) \underline{kisebb}, mint a hova rúd felső korongja, AKKOR this[honnan legfelső korongja] := hova
	
	\subsection{Állapottér-reprezentáció gráf-reprezentációja}
	\underline{$\delta$-gráf} ~ állapot-gráf\\
	-csúcs: állapot\\
	-irányított él: művelet hatása\\
	-élköltség: művelet költsége\\
	\underline{startcsúcs} ~ kezdőállapot\\
	\underline{célcsúcsok} ~ végállapotok\\
	\underline{irányított út} ~ egy műveletsorozat hatása\\
	
	\subsection{Állapottér vs. problématér}
	-Az állapottér-reprezentáció és a problématér között szoros kapcsolat áll fenn, de az állapottér többnyire nem azonos a problématérrel.\\
	-A problématér elemeit többnyire nem az állapotok, hanem a startcsúcsból induló különböző hosszúságú irányított utak.\\
	\hspace*{1em} -A hanoi tornyai problémánál például egy megoldást egy irányított út\\ \hspace*{1em} szimbolizál, amelyik a startcsúcsból a célcsúcsba vezet.\\
	\hspace*{1em} -Van amikor a megoldás egyetlen álapot (azaz csúcs), de ebben az esetben is\\ \hspace*{1em} kell találni egy odavezető operátor-sorozatot (azaz irányított utat).
	 
	 \subsection{Állapot-gráf bonyolultsága}
	 Állapot-gráf bonyolultsága $\rightarrow$ Problématér mérete $\rightarrow$ Keresés számításigénye\\ \\
	 A bonyolultság elsősorban a start csúcsból kivezető utak száma az oda-vissza lépések nélkül, amely nyilván függvénye a\\
	 \hspace*{1em} -csúcsok és élek számának\\
	 \hspace*{1em} -csúcsok ki-fokának\\
	 \hspace*{1em} -körök gyakoriságának, és hosszuk sokféleségének\\ \\
	 Ugyanannak a feladatnak több modellje lehet: érdemes olyat keresni, amely kisebb problémateret jelöl ki.\\
	 \hspace*{1em} -Az előző reprezentációnál a problématér mérete, azaz a lehetséges utak \\ \hspace*{1em}száma, óriási. Készítsünk jobb modellt!\\
	 \hspace*{1em}-Bővítsük az állapotteret, és használjunk új műveletet!\\
	 \hspace*{1em}-Műveletek előfeltételének szigorításával csökken az állapot-gráf átlagos ki-foka.
	 
	 \subsection{Művelet végrehajtásának hatékonysága}
	 A művelet kiszámítási bonyolultsága csökkenthető, ha az állapotokat extra információval egészítjük ki, vagy az invariáns szigorításával szűkítjük az állapotteret. \\ 
	 
	 \subsection{Hogyan "látja" egy keresés a reprezentációs gráfot?}
	 Egy keresés fokozatosan fedezi fel a reprezentációs gráfot:
	 bizonyos részeihez soha nem jut el, de a felfedezett részt sem feltétlenül tárolja el teljesen, sőt, sokszor torzultan "látja" azt: ha például egy csúcshoz érve nem vizsgálja meg, hogy ezt korábban már felfedezte-e, hanem új csúcsként regisztrálja, akkor az eredeti gráf helyett egy fát fog tárolni.
	 
	 \subsection{Reprezentációs gráf "fává egyenesítése"}
	 Ha a keresés nem vizsgálja meg egy csúcsról, hogy korábban már felfedezte-e, akkor az eredeti reprezentációs gráf helyett annak fává kiegyenesített változatában keres.\\
	 Előny: eltűnnek a körök, de a megoldási utak megmaradnak.\\
	 Hátrány: duplikátumok jelennek meg, sőt a körök kiegyenesítése végtelen hosszú utakat eredményez.\\
	 A kétirányú (oda-vissza) élek szörnyen megnövelik a kiegyenesítéssel kapott fa méretét. De bármelyik keresésnél eltárolhatjuk egy csúcsnak azt a szülőcsúcsát, amelyik felől a csúcsot elértük. Így egy csúcsból a szülőjébe visszavezető él könnyen felismerhető és figyelmen kívül hagyható.
	 
	 \section{Probléma dekompozíció}
	 Egy probléma dekomponálása során a problémát részproblémákra bontjuk, majd azokat tovább részletezzük, amíg nyilvánvalóan megoldható problémákat nem kapunk.\\
	 Sokszor egy probléma megoldását akár többféleképpen is fel lehet bontani részproblémák megoldásaira.
	 
	 \subsection{Dekompozíciós reprezentáció fogalma}
	 A reprezentációhoz meg kell adnunk:\\
	 -a feladat részproblémáinak általános leírását\\
	 -a kiinduló problémát\\
	 -az egyszerű problémákat, amelyekről könnyen eldönthető, hogy megoldhatók-e vagy sem\\
	 -a dekomponáló műveleteket:\\
	 \hspace*{1em}D: probléma $\rightarrow$ probléma$\textsuperscript{+}$\\
	 \hspace*{1em}D(p)= $<$p$\textsubscript{1}$,...,p$\textsubscript{n}$$>$
	 
	 \subsection{A dekompozíció modellezése ÉS/VAGY gráffal}
	 Egy dekompozíciót egy ún. ÉS/VAGY gráffal szemléltetjük:
	 -egy csúcs egy részproblémát jelöl, a startcsúcs a kiinduló problémát, a célcsúcsok a megoldható egyszerű problémákat.
	 -egy élköteg egy dekomponáló művelet hatását írja le, és a dekomponált probléma csúcsából a dekomponálással előállított részproblémák csúcsaiba vezet.\\
	 \hspace*{1em}- egy élköteg élei mutatják meg, hogy a dekomponált probléma megoldásához\\
	 \hspace*{1em}  mely részproblémákat kell megoldani. Az élköteg élei között ezért ún. "ÉS"\\
	 \hspace*{1em}  kapcsolat van: hiszen minden részproblémát meg kell oldani.\\
	 \hspace*{1em}- egy csúcsból több élköteg is indulhat, ha egy probléma többféleképpen\\
	 \hspace*{1em} dekomponálható. Ezen élkötegek élei között ún. "VAGY" kapcsolat áll fenn:\\
	 \hspace*{1em} hiszen választhatunk, hogy melyik élköteg mentén oldjunk meg egy problémát.
	 
	 \subsection{ÉS/VAGY gráfok}
	 1. AZ R=(N,A) élsúlyozott irányított hiper-gráf, ahol az\\
	 \hspace*{1em}-N a csúcsok halmaza\\
	 \hspace*{1em}-A $\subseteq$ \{ (n,M)$\in$ NxN$\textsuperscript{+}$ $|$ 0$\neq$$|$M$|$ $<$ $\infty$ \} a hiper-élek halmaza, $|$M$|$ a hiper-él\\
	 \hspace*{1em} rendje\\
	 \hspace*{1em}-(c(n,M) az (n,M) költsége)\\
	 2. Egy csúcsból véges sok hiper-él indulhat\\
	 3. (0$<$$\delta$$\leq$c(n,M))
	 
	 \subsection{Megoldás-gráf}
	 Az eredeti problémát egyszerű problémákra visszavezető dekomponálási folyamatot az ÉS/VAGY gráf speciális részgráfja, az ún. megoldás-gráf jeleníti meg, amelyben:\\
	 \hspace*{1em} -szerepel a startcsúcs\\
	 \hspace*{1em} -a startcsúcsból minden más csúcsba vezet út, és minden csúcsból vezet út\\
	 \hspace*{1em} egy megoldás-gráfbeli célcsúcsba\\
	 \hspace*{1em} -egy éllel együtt az összes azzal "ÉS" kapcsolatban álló él is (azaz a teljes\\
	 \hspace*{1em} élköteg) része a megoldás-gráfnak\\
	 \hspace*{1em} -nem tartalmaz "VAGY" kapcsolatban álló él párokat\\
	 A megoldás a megoldás-gráfból olvasható ki.
	 
	 \subsection{Az n csúcsból az M csúcs-sorozatba vezető irányított hiper-út fogalma}
	 Az n$\textsuperscript{$\alpha$}$$\rightarrow$M hiper-út (n$\in$N,M$\in$N$\textsuperscript{+}$) egy olyan véges részgráf, amelyben:\\
	 \hspace*{1em}-M csúcsaiból nem indul hiper-él\\
	 \hspace*{1em}-M-en kívüli csúcsokból csak egy hiper-él indul\\
	 \hspace*{1em}-minden csúcs elérhető az n csúcsból egy közönséges irányított úton.\\
	 A megoldás-gráf egy olyan hiper-út, amely a startcsúcsból csupa célcsúcsba vezet.
	 
	 \subsection{Hiper-út bejárása}
	 Az n$\rightarrow$M hiper-út egy bejárásán a hiper-út csúcsaiból képzett sorozatoknak a felsorolását értjük:\\
	 \hspace*{1em} -első sorozat: $<$n$>$\\
	 \hspace*{1em} -a C sorozatot a C$\textsuperscript{k$\leftarrow$K}$ sorozat követi (ahol a k$\in$C, és\\
	 \hspace*{1em} k minden C-beli előfordulásának helyén a K sorozat szerepel) feltéve, hogy a\\
	 \hspace*{1em} hiper-útnak van olyan (k,K) hiper-éle, ahol k$\notin$M.\\
	 
	 \subsection{Útkeresés ÉS/VAGY gráfban}
	 Amikor a startcsúcsból induló hiper-utakat (ezek között vannak a megoldás-gráfok is, ha egyáltalán vannak ilyenek) a bejárásukkal írjuk le, akkor ezek a bejárások olyan közönséges irányított utak, amelyek csúcsai az eredeti ÉS/VAGY gráf csúcsainak sorozatai. Ezen utakból egy olyan közönséges irányított gráfot készíthetünk, amelyben a startcsúcs az ÉS/VAGY gráf startcsúcsából álló egy elemű sorozat, a célcsúcsait leíró sorozatok pedig kizárólag az ÉS/VAGY gráf célcsúcsainak egy részét tartalmazzák.\\
	 Ha ebben a közönséges gráfban megoldási utat találunk, akkor az egyben az eredeti ÉS/VAGY gráf megoldás-gráfja is lesz.
	 
	 
	 \section{Keresések}
	 
	 \subsection{KR vezérlési szintjei}
	 Három féle vezérlési stratégiát különböztetünk meg:\\
	 -általános (független a feladattól, és annak modelljétől: nem merít sem a feladat\\ \hspace*{0,2em}ismereteiből, sem a modell sajátosságaiból.)\\
	 -modellfüggő (nem függ a feladat ismereteitől, de épít a feladat modelljének\\
	 \hspace*{0,2em} általános elemeire.)\\
	 -heurisztikus (a feladattól származó, annak modelljében nem rögzített, a megoldást\\
	 \hspace*{0,2em} segítő speciális ismeret)
	 
	 Másik megközelítés alapján, kétféle általános stratégiát különböztetünk meg:\\
	 -nemmódosítható (lokális keresések, evolúciós algoritmus, rezolúció)\\
	 -módosítható (visszalépéses keresések, gráfkeresések)
	 
	 \subsection{Lokális keresések}
	 A lokális keresés olyan KR, amely a probléma reprezentációs gráfjának egyetlen csúcsát (aktuális csúcs) és annak szűk környezetét tárolja (a globális munkaterületén).\\
	 Kezdetben az aktuális csúcs a startcsúcs, és a keresés akkor áll le, ha az aktuális csúcs a célcsúcs lesz.\\
	 Az aktuális csúcsot minden lépésben annak környezetéből vett "jobb" csúccsal cseréli le (keresési szabály).\\
	 A "jobbság" eldöntéséhez (vezérlési stratégia) egy kiértékelő (cél-,\\ rátermettségi-, heurisztikus) függvényt használ, amely reményeink szerint annál jobb értéket ad egy csúcsra, minél közelebb esik az a célhoz.
	 
	 \subsection{Hegymászó algoritmus}
	 Mindig az aktuális (akt) csúcs legjobb gyermekére lép, amelyik lehetőleg nem a szülője.\\
	 (Megjegyzés: Az eredeti hegymászó algoritmus nem zárja ki a szülőre való lépést, viszont nem engedi meg, hogy az aktuális csúcsot egy rosszabb értékű csúcsra cseréljük, ilyenkor inkább leáll.)\\
	 \underline{Hátrányok:}\\
	 Csak erős heurisztika esetén lesz sikeres: különben "eltéved" (nem talál megoldást), sőt zsákutcába jutva "beragad".\\
	 Segíthet, ha:\\
	 \hspace*{0,5em} -véletlenül választott startcsúcsból újra- és újra elindítjuk (random restart\\ \hspace*{1,1em}local search)\\
	 \hspace*{0,5em} -k darab aktuális csúcs legjobb k darab gyerekére lépünk (local beam search)\\
	 \hspace*{0,5em} -gyengítjük a mohó stratégiáját (simulated annealing)\\
	 Lokális optimum hely körül vagy ekvidisztans felületen (azonos értékű szomszédos csúcsok között) található körön, végtelen működésbe eshet.\\
	 Segíthet ha:\\
	 \hspace*{0,5em} -növeljük a memóriát (tabu search)\\ \\
	 
	 \subsection{Tabu keresés}
	 A globális munkaterületén az aktuális csúcson (akt) kívül nyilvántartja még:\\
	 \hspace*{0,5em} -az utolsó néhány érintett csúcsot: Tabu halmaz\\
	 \hspace*{0,5em} -az eddigi legjobb csúcsot: optimális csúcs (opt)\\ \\
	 Egy keresési szabály minden lépésben\\
	 \hspace*{0,5em} -az aktuális csúcsnak a legjobb, de nem a Tabu halmazban lévő gyerekére lép\\
	 \hspace*{0,5em} -ha akt jobb, mint az opt, akkor opt az akt lesz\\
	 \hspace*{0,5em} -frissíti akt-tal a sorszerkezetű Tabu halmazt\\ \\
	 Terminálási feltételek:\\
	 \hspace*{0,5em} -ha az opt a célcsúcs\\
	 \hspace*{0,5em} -ha az opt sokáig nem változik \\ \\
	 \underline{Előnyök:}\\
	 Tabu méreténél rövidebb köröket észleli, és ez segíthet a lokális optimum hely illetve az ekvidisztans felület körüli körök leküzdésében.\\ \\
	 \underline{Hátrányok:}
	 A tabu halmaz méretét kísérletezéssel kell belőni. \\
	 Zsákutcába futva nem-módosítható stratégia miatt beragad.
	 
	 \subsection{Szimulált hűtés}
	 A keresési szabály a következő csúcsot véletlenszerűen választja ki az aktuális (akt) csúcs gyermekei közül.\\
	 Ha az így kiválasztott új csúcs kiértékelő függvény-értéke nem rosszabb, mint az akt csúcsé (itt f(új) $\leq$ f(akt)), akkor elfogadjuk aktuális csúcsnak.\\
	 Ha az új csúcs függvényértéke rosszabb (itt f(új) $>$ f(akt)), akkor egy olyan véletlenített módszert alkalmazunk, ahol az új csúcs elfogadásának valószínűsége fordítottan arányos az $|$ f(akt) - f(új) $|$ különbséggel: \\
	 $e^\frac{f(akt)-f(uj)}{T}$ $>$ random[0,1] \\
	 
	 \subsection{Hűtési ütemterv}
	 Egy csúcs elfogadásának valószínűségét az elfogadási képlet kitevőjének T együtthatójával szabályozhatjuk. Ezt egy (T$\textsubscript{k}$,L$\textsubscript{k}$) k=1,2,... ütemterv vezérli, amely L$\textsubscript{1}$, majd L$\textsubscript{2}$ lépésen keresztül T$\textsubscript{2}$, stb. lesz.\\
	 $e^\frac{f(current)-f(new)}{T_k}$ $>$ rand[0,1]\\
	 Ha $T_1$, $T_2$, ... szigorúan monoton csökken, akkor egy ugyanannyival rosszabb függvényértékű új csúcsot kezdetben nagyobb valószínűséggel fogad el a keresés, mint később.
	 
	 \subsection{Lokális kereséssel megoldható feladatok}
	 Erős heurisztika nélkül nincs sok esély a cél megtalálására.\\
	 \hspace*{0,5em} -Jó heurisztikára épített kiértékelő függvénnyel elkerülhetőek a zsákutcák,\\
	 \hspace*{0,5em} a körök.\\
	 A sikerhez az kell, hogy egy lokálisan hozott rossz döntés ne zárja ki a cél megtalálását!\\
	 \hspace*{0,5em} -Ez például egy erősen összefüggő reprezentációs-gráfban automatikusan \\
	 \hspace*{1em}teljesül, de kifejezetten előnytelen, ha a reprezentációs-gráf egy irányított fa. (Például az n-királynő problémákat csak tökéletes kiértékelő függvény esetén lehetne lokális kereséssel megoldani.)
	 
	 \subsection{A heurisztika hatása a KR működésére}
	 A heurisztika olyan, a feladathoz kapcsolódó ötlet, amelyet közvetlenül építünk be egy algoritmusba azért, hogy annak eredményessége és hatékonysága javuljon ( egyszerre képes javítani a futási időt és a memóriaigényt), habár erre általában semmiféle garanciát nem ad.
	 
	 \section{Visszalépéses keresés}
	 A visszalépéses keresés egy olyan KR, amely:\\
	 \hspace*{1em} -globális munkaterülete:\\
	 \hspace*{2em} egy út a startcsúcsból az aktuális csúcsba (ezen kívül az útról leágazó \\
	 \hspace*{2em} még ki nem próbált élek)\\
	 \hspace*{3em} kezdetben a startcsúcsot tartalmazó nulla hosszúságú út\\
	 \hspace*{3em} terminálás célcsúccsal vagy startcsúcsból való visszalépéssel\\
	 \hspace*{1em} -keresés szabályai:\\
	 \hspace*{2em} a nyilvántartott út végéhez egy új (ki nem próbált) él hozzáfűzése, vagy\\
	 \hspace*{2em} a legutolsó él törlése (visszalépés szabálya)\\
	 \hspace*{1em} -vezérlés stratégiája a visszalépés szabályát csak a legvégső esetben\\
	 \hspace*{1em}  alkalmazza\\
	 
	 \subsection{Visszalépés feltételei}
	 -Zsákutca: az aktuális csúcsból (azaz az aktuális út végpontjából) nem vezet\\
	 \hspace*{1em} tovább él\\
	 -Zsákutca torkolat: az aktuális csúcsból kivezető utak nem vezettek célba\\
	 -Kör: az aktuális csúcs szerepel már korábban is az aktuális úton\\
	 -Mélységi korlát: az aktuális út hossza elér egy előre megadott értéket
	 
	 \newpage
	 \subsection{Alacsonyabb rendű vezérlési stratégiák}
	 -A vezérlési stratégia kiegészíthető:\\
	 \hspace*{1em} -sorrendi szabállyal: sorrendet ad az aktuális út végpontjából kivezető \\
	 \hspace*{2em} élek (utak) vizsgálatára\\
	 \hspace*{1em} -vágó szabállyal: megjelöli azokat az aktuális út végpontjából kivezető \\
	 \hspace*{2em} éleket (utakat), amelyeket nem érdemes megvizsgálni\\
	 -Ezek a szabályok lehetnek:\\
	 \hspace*{1em} -másodlagos vezérlési stratégiák (a probléma modelljének sajátosságaiból \\
	 \hspace*{2em} származó ötlet)\\
	 \hspace*{1em} -heurisztikák (a probléma ismereteire támaszkodó ötlet)\\
	 
	 \subsection{Első változat: VL1}
	 A visszalépéses algoritmus első változata az, amikor a visszalépés feltételei közül az első kettőt építjük be a kereső rendszerbe.\\
	 Bebizonyítható: Véges körmentes irányított gráfokon a VL1 mindig terminál, és ha létezik megoldás, akkor talál egyet. UI: véges sok adott startból induló út van.\\
	 Rekurzív algoritmussal (VL1) szokták megadni.
	 
	 \subsection{Az n-királynő probléma új reprezentációs modellje}
	 Az előző módszerek átalakították az n-királynő probléma reprezentációját:\\
	 \hspace*{1em} Tekintsük a $D_1$,...,$D_n$ halmazokat, ahol $D_i$={1...n} \\
	 \hspace*{1em} (ezek az i-dik sor szabad mezői).\\
	 \hspace*{1em} Keressük azt az ($x_1$,...,$x_n$) $\in$ $D_1$ x ... x $D_n$ elhelyezést ($x_i$ az i-dik sorban\\
	 \hspace*{1em} elhelyezett királynő oszloppozíciója),\\
	 \hspace*{1em} amely nem tartalmaz ütést: minden i,j királynő párra:\\
	 \hspace*{1em} C$\textsubscript{ij}$($x_i$,$x_j$) $\equiv$ ($x_i$$\neq$$x_j$ $\bigwedge$ $|$$x_i$-$x_j$$|$$\neq$$|$i-j$|$).\\
	 A visszalépéses keresés e modell változóinak értékeit határozza meg, miközben a bemutatott vágó módszerek egyike redukálják ezen változók $D_i$ halmazait.
	 
	 \subsection{Bináris korlát-kielégítési modell}
	 Keressük azt az ($x_i$,...,$x_n$) $\in$ $D_1$ x...x$D_n$ n-est ($D_i$ véges) amely kielégít néhány C$\textsubscript{ij}$$\subseteq$ $D_i$x$D_j$ bináris korlátot.\\
	 Példa:\\
	 Házasságközvetítő probléma (n férfi, m nő, keressünk minden férfinak neki szimpatikus feleségjelöltet):\\
	 \hspace*{1em} -Az i-dik férfi (i=1..n) felesége ($x_i$) a $D_i$={1,...,m} azon elemei, amelyekre fenn \\
	 \hspace*{2em} áll, hogy szimpatikus(i,$x_i$).\\
	 \hspace*{1em} -Az összes (i,j)-re: C$\textsubscript{ij}$($x_i$,$x_j$) $\equiv$ ($x_i$,$x_j$) (azaz nincs bigámia)
	 
	 \subsection{Modellfüggő vezérlési stratégia}
	 A korábban mutatott vágó módszereket az új modellben a bináris korlátok definiálják, de a korlátok jelentésétől függetlenül. Ezek a módszerek tehát nem heurisztikák, hanem modellfüggő vágó stratégiák:\\
	 \hspace*{1em} Töröl(i,k): $D_i$:= $D_i$- \{ e$\in$$D_i$$|$ $\neg$C$\textsubscript{ik}$(e,$x_k$)\}\\
	 \hspace*{1em} Szűr(i,j) :$D_i$:=  $D_i$ - \{ e$\in$$D_i$ $|$ $\forall$f$\in$$D_j$:$\neg$C$\textsubscript{ij}$(e,f)\}\\
	 Modellfüggő sorrendi stratégiák is konstruálhatók:\\
	 \hspace*{1em} -Mindig a legkisebb tartományú még kitöltetlen komponensek válasszunk\\
	 \hspace*{2em} előbb értéket.\\
	 \hspace*{1em}- Ugyanazon korláthoz tartozó komponenseket lehetőleg közvetlenül egymás\\
	 \hspace*{2em} után töltsük ki.\\
	 
	 
	 
	 
	
		
\end{document}



