\documentclass{article}


\begin{document}
	
	\title{Mesterséges Intelligencia}
	\author{Vass Miklós Szilveszter}
	
	\section{AZ MI FOGALMA}
	\subsection{Miről ismerhető fel az MI?}
	\underline{Megoldandó feladat:} nehéz\\
	- A feladat problématere hatalmas\\	
	-Szisztematikus keresés helyett intuícióra, kreativitásra (azaz heurisztikára) van szükségünk ahhoz, hogy elkerljük a kombinatorikus robbanást.\\
	\underline{Szoftver viselkedése:} intelligens (tárol ismeretet, automatikusan következtet, tanul, gépi látás, gépi cselekvés)\\
	-Turing teszt vs. kínai szoba elmélet\\
	-"mesterjelölt szintű" mesterséges intelligencia\\
	\underline{Felhasznált eszközök:} sajátosak\\
	-Átgondolt reprezentáció a feladat modellezéséhez\\
	-Heurisztikával megerősített hatékony algoritmusok\\
	-Gépi tanulás módszerei\\
	
	\section{MODELLEZÉS ÉS KERESÉS}
	feladat $\rightarrow$ útkeresési probléma $\rightarrow$ megoldás\\
	Feladat és útkeresési probléma között helyezkedik el a modellezés. Itt található az állapottér-reprezentáció, a probléma dekompozíció, a korlátprogramozási modell, és a logikai reprezentáció.\\
	Az útkeresési problémát egy gráffal reprezentálhatjuk.
	Az útkeresési probléma és a megoldás között található a keresés. A keresésbe tartoznak a lokális keresések, a visszalépéses keresések, a gráfkeresések, az evolúciós algoritmus, a rezolúció és a szabályalapú következtetés.\\
	
	\subsection{Mire kell a modellezésnek fókuszálni}
	Problématér elemei: probléma lehetséges válaszai.\\
	Cél: egy helyes válasz (megoldás) megtalálása\\
	Keresést segítő ötletek (heurisztikák): \\
	-Problématér hasznos elemeinek elválasztása a haszontalanoktól.\\
	-Az elemek szomszédsági kapcsolatainak kijelölése, hogy a probléma tér elemeinek szisztematikus bejárását segítsük.\\
	-Adott pillanatban elérhető elemek rangsorolása.\\
	-Kiinduló elem kijelölése.\\
	
	\subsection{Útkeresési probléma}
	Egy útkeresési problémában a problématér elemeit egy olyan élsúlyozott irányított gráf csúcsai vagy útjai szimbolizálják, amelyik gráf nem feltétlenül véges, de a csúcsainak kifoka véges, és van egy közös pozitív alsó korlátja az élek súlyának (költségének) ($\delta$-gráf).\\
	A megoldást ennek megfelelően vagy egy célcsúcs, vagy egy startcsúcsból célcsúcsba vezető út (esetleg a legolcsóbb ilyen) megtalálása szolgáltatja.\\
	Számos olyan modellező módszert ismerünk, amely a kitűzött feladatot útkeresési problémává fogalmazza át.
	
	\subsection{Gráf fogalmak}
	-csúcsok, irányított élek:$\rightarrow$ N, A $\subseteq$ NxN\\
	-él n-ből m-be $\rightarrow$ (n,m) $\in$ A (n,m $\in$ N)\\
	-n utódai $\rightarrow$ $\gamma$ (n) = $\{$ m $\in$ N $\mid$ (n,m) $\in$ A $\}$\\
	-n szülei $\rightarrow$ $\pi$(n) $\in$ $\Pi$(n) = $\{$ m $\in$ N $\mid$ (m,n) $\in$ A $\}$\\
	-irányított gráf $\rightarrow$ R=(N,A)\\
	-véges sok kivezető él $\rightarrow$ $\mid$ $\gamma$ (n) $\mid$ $<$ $\infty$ ($\forall$ n $\in$ N)\\
	-élköltség $\rightarrow$ c:A $\rightarrow$ ${\rm I\!R}$\\
	-$\delta$ tulajdonság ($\delta$$\in$${\rm I\!R^+}$) $\rightarrow$ c(n,m) $\geq$ $\delta$ $>$ 0 ($\forall$(n,m)$\in$A)\\
	-$\delta$-gráf $\rightarrow$ $\delta$-tulajdonságú, véges sok kivezető élű, élsúlyozott irányított gráf\\
	-irányított út $\rightarrow$ $\alpha$ = (n,$n_1$),($n_1$,$n_2$),...,(n$\textsubscript{k-1}$,m) = $<$n,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m$>$ n$\rightarrow$$\textsuperscript{$\alpha$}$m, n$\rightarrow$ m, n$\rightarrow$M (M $\subseteq$ N) {n$\rightarrow$m}, {n$\rightarrow$M}\\
	-út hossza $\rightarrow$ az út éleinek száma: $|$$\alpha$$|$\\
	-út költsége $\rightarrow$ c($\alpha$)=c$\textsuperscript{$\alpha$}$(n,m) :=  $\sigma$$\textsubscript{j=1..k}$c(n$\textsubscript{j-1}$,$n_j$) ha $\alpha$ = $<$n=$n_0$,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m=$n_k$$>$\\
	-opt. költség $\rightarrow$ c*(n,m):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,m) $\{$$\delta$ gráfokban ez végtelen sok út esetén is értelmes. Értéke $\infty$, ha nincs egy út se.$\}$ \\
	-opt. költség2 $\rightarrow$ c*(n,M):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,M) \\
	-opt. költségű út n$\rightarrow$*m :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$m$\}$ $\}$ \\
	-opt. költségű út n$\rightarrow$*M :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$M$\}$ $\}$ \\
	
	\subsection{Gráfreprezentáció fogalma}
	Minden útkeresési probléma rendelkezik egy (a probléma modellezéséből származó) gráfreprezentációval, ami egy (R,s,T) hármas, amelyben:\\
	-R=(N,A,c) $\delta$-gráf az ún. reprezentációs gráf,\\
	-az s$\in$N startcsúcs,\\
	-a T$\subseteq$N halmazbeli célcsúcsok.\\
	És a probléma megoldása:\\
	-egy t$\in$T cél megtalálása, vagy\\
	-egy s$\rightarrow$T, esetleg s$\rightarrow$*T optimális út megtalálása\\
	(s-ből Tegyik csúcsába vezető irányított út, vagy s-ből T egyik csúcsába vezető legolcsóbb irányított út)\\
	Az útkeresési problémák megoldásáshoz azok a reprezentációs gráfjainak nagy mérete miatt speciális (nem determinisztikus, heurisztikus) útkereső algoritmusokra van szükség, amelyek:\\
	-a startcsúcsból indulnak, amely az első aktuális csúcs;\\
	-minden lépésben nem-determinisztikus módon új aktuális csúcso(ka)t választanak a korábbi aktuális csúcs(ok) alapján (gyakran azok gyerekei közül);\\
	-tárolják a már feltárt reprezentációs gráf egy részét;\\
	-megállnak, ha célcsúcsot találnak vagy nyilvánvalóvá válik, hogy erre semmi esélyük.\\
	
	\subsection{Kereső rendszer (KR)}
	Procedure KR\\
	1. ADAT:= kezdeti érték\\
	2. while !terminálási feltétel(ADAT) loop\\
	3. \quad SELECT SZ FROM alkalmazható szabályok\\
	4. \quad ADAT := SZ(ADAT)\\
	5. endloop\\
	end\\
	AHOL:\\
	-ADAT: globális munkaterület, tárolja a keresés során megszerzett és megőrzött ismeretet\\
	-alkalmazható szabályok: keresési szabályok, megváltoztatják a globális munkaterület tartalmát\\
	-SELECT: vezérlési stratégia, alkalmazható szabályok közül kiválaszt egy "megfelelőt"
	
	\subsection{Kereső rendszerek vizsgálata}
	-helyes-e (azaz korrekt választ ad-e)\\
	-teljes-e (minden esetben választ ad-e)\\
	-optimális-e(optimális megoldást ad-e)\\
	-idő bonyolultság\\
	-tár bonyolultság\\
	
	\section{GÉPI TANULÁS}
	-Egy programozási feladat megoldásához meg kell adnunk a feladat modelljét és készítenünk kell egy ehhez illeszkedő algoritmust, amely a feladat megoldását előállítja.\\
	-Gépi tanulással a modell (reprezentáció és/vagy heurisztika), illetve a megoldó algoritmus (többnyire annak bizonyos paraméterei) állhatnak elő automatikusan.\\
	-A tanuláshoz a megoldandó probléma néhány konkrét esetére, a tanító példákra van szükség.\\
	-A gépi tanulási módszereket három csoportba szokás sorolni: felügyelt-, nem-felügyelt, és megerősítéses tanulásra attól függően, hogy a tanító példák input-output párok, csak inputok, vagy input-hasznosság párok.\\
	
	\section{Állapottér-reprezentáció}
	\underline{Állapottér}: a probléma leírásához szükséges adatok által felvett érték-együttesek (azaz állapotok) halmaza\\
	-az állapot többnyire egy összetett szerkezetű érték\\
	-gyakran egy bővebb alaphalmazzal és egy azon értelmezett invariáns állítással definiáljuk\\
	\underline{Múveletek}: állapotból állapotba vezetnek.\\
	-megadásukhoz: előfeltétel és hatás leírása\\
	-invariáns tulajdonságot tartó leképezés\\
	\underline{Kezdőállapot(ok)} vagy azokat leíró kezdeti feltétel\\
	\underline{Végállapot(ok)} vagy célfeltétel
	
	\subsection{Hanoi tornyai probléma}
	
	\underline{Állapottér:}
	AT=$\{$1,2,3$\}$\textsuperscript{n}\\
	megjegyzés: a tömb i-dik eleme mutatja az i-dik korong rúdjának számát, a korongok a rudakon méretük szerint fentről lefelé növekvő sorban vannak.\\	
	\underline{Művelet:}Rak(honnan,hova): AT$\rightarrow$AT honnan, hova $\in$ \{1,2,3\}\\
	HA a honnan és hova \underline{létezik} és \underline{nem azonos}, és \underline{van korong} a honnan rúdon, és a hova rúd \underline{üres} vagy a mozgatandó korong (honnan rúd felső korongja) \underline{kisebb}, mint a hova rúd felső korongja, AKKOR this[honnan legfelső korongja] := hova
	
	\subsection{Állapottér-reprezentáció gráf-reprezentációja}
	\underline{$\delta$-gráf} ~ állapot-gráf\\
	-csúcs: állapot\\
	-irányított él: művelet hatása\\
	-élköltség: művelet költsége\\
	\underline{startcsúcs} ~ kezdőállapot\\
	\underline{célcsúcsok} ~ végállapotok\\
	\underline{irányított út} ~ egy műveletsorozat hatása\\
	
	\subsection{Állapottér vs. problématér}
	-Az állapottér-reprezentáció és a problématér között szoros kapcsolat áll fenn, de az állapottér többnyire nem azonos a problématérrel.\\
	-A problématér elemeit többnyire nem az állapotok, hanem a startcsúcsból induló különböző hosszúságú irányított utak.\\
	\hspace*{1em} -A hanoi tornyai problémánál például egy megoldást egy irányított út\\ \hspace*{1em} szimbolizál, amelyik a startcsúcsból a célcsúcsba vezet.\\
	\hspace*{1em} -Van amikor a megoldás egyetlen álapot (azaz csúcs), de ebben az esetben is\\ \hspace*{1em} kell találni egy odavezető operátor-sorozatot (azaz irányított utat).
	 
	 \subsection{Állapot-gráf bonyolultsága}
	 Állapot-gráf bonyolultsága $\rightarrow$ Problématér mérete $\rightarrow$ Keresés számításigénye\\ \\
	 A bonyolultság elsősorban a start csúcsból kivezető utak száma az oda-vissza lépések nélkül, amely nyilván függvénye a\\
	 \hspace*{1em} -csúcsok és élek számának\\
	 \hspace*{1em} -csúcsok ki-fokának\\
	 \hspace*{1em} -körök gyakoriságának, és hosszuk sokféleségének\\ \\
	 Ugyanannak a feladatnak több modellje lehet: érdemes olyat keresni, amely kisebb problémateret jelöl ki.\\
	 \hspace*{1em} -Az előző reprezentációnál a problématér mérete, azaz a lehetséges utak \\ \hspace*{1em}száma, óriási. Készítsünk jobb modellt!\\
	 \hspace*{1em}-Bővítsük az állapotteret, és használjunk új műveletet!\\
	 \hspace*{1em}-Műveletek előfeltételének szigorításával csökken az állapot-gráf átlagos ki-foka.
	 
	 \subsection{Művelet végrehajtásának hatékonysága}
	 A művelet kiszámítási bonyolultsága csökkenthető, ha az állapotokat extra információval egészítjük ki, vagy az invariáns szigorításával szűkítjük az állapotteret. \\ 
	 
	 \subsection{Hogyan "látja" egy keresés a reprezentációs gráfot?}
	 Egy keresés fokozatosan fedezi fel a reprezentációs gráfot:
	 bizonyos részeihez soha nem jut el, de a felfedezett részt sem feltétlenül tárolja el teljesen, sőt, sokszor torzultan "látja" azt: ha például egy csúcshoz érve nem vizsgálja meg, hogy ezt korábban már felfedezte-e, hanem új csúcsként regisztrálja, akkor az eredeti gráf helyett egy fát fog tárolni.
	 
	 \subsection{Reprezentációs gráf "fává egyenesítése"}
	 Ha a keresés nem vizsgálja meg egy csúcsról, hogy korábban már felfedezte-e, akkor az eredeti reprezentációs gráf helyett annak fává kiegyenesített változatában keres.\\
	 Előny: eltűnnek a körök, de a megoldási utak megmaradnak.\\
	 Hátrány: duplikátumok jelennek meg, sőt a körök kiegyenesítése végtelen hosszú utakat eredményez.\\
	 A kétirányú (oda-vissza) élek szörnyen megnövelik a kiegyenesítéssel kapott fa méretét. De bármelyik keresésnél eltárolhatjuk egy csúcsnak azt a szülőcsúcsát, amelyik felől a csúcsot elértük. Így egy csúcsból a szülőjébe visszavezető él könnyen felismerhető és figyelmen kívül hagyható.
	 
	 \section{Probléma dekompozíció}
	 Egy probléma dekomponálása során a problémát részproblémákra bontjuk, majd azokat tovább részletezzük, amíg nyilvánvalóan megoldható problémákat nem kapunk.\\
	 Sokszor egy probléma megoldását akár többféleképpen is fel lehet bontani részproblémák megoldásaira.
	 
	 \subsection{Dekompozíciós reprezentáció fogalma}
	 A reprezentációhoz meg kell adnunk:\\
	 -a feladat részproblémáinak általános leírását\\
	 -a kiinduló problémát\\
	 -az egyszerű problémákat, amelyekről könnyen eldönthető, hogy megoldhatók-e vagy sem\\
	 -a dekomponáló műveleteket:\\
	 \hspace*{1em}D: probléma $\rightarrow$ probléma$\textsuperscript{+}$\\
	 \hspace*{1em}D(p)= $<$p$\textsubscript{1}$,...,p$\textsubscript{n}$$>$
	
		
\end{document}



