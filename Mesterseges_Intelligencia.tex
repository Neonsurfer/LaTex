\documentclass{article}


\begin{document}
	
	\title{Mesterséges Intelligencia}
	\author{Vass Miklós Szilveszter}
	
	\section{AZ MI FOGALMA}
	\subsection{Miről ismerhető fel az MI?}
	\underline{Megoldandó feladat:} nehéz\\
	- A feladat problématere hatalmas\\	
	-Szisztematikus keresés helyett intuícióra, kreativitásra (azaz heurisztikára) van szükségünk ahhoz, hogy elkerljük a kombinatorikus robbanást.\\
	\underline{Szoftver viselkedése:} intelligens (tárol ismeretet, automatikusan következtet, tanul, gépi látás, gépi cselekvés)\\
	-Turing teszt vs. kínai szoba elmélet\\
	-"mesterjelölt szintű" mesterséges intelligencia\\
	\underline{Felhasznált eszközök:} sajátosak\\
	-Átgondolt reprezentáció a feladat modellezéséhez\\
	-Heurisztikával megerősített hatékony algoritmusok\\
	-Gépi tanulás módszerei\\
	
	\section{MODELLEZÉS ÉS KERESÉS}
	feladat $\rightarrow$ útkeresési probléma $\rightarrow$ megoldás\\
	Feladat és útkeresési probléma között helyezkedik el a modellezés. Itt található az állapottér-reprezentáció, a probléma dekompozíció, a korlátprogramozási modell, és a logikai reprezentáció.\\
	Az útkeresési problémát egy gráffal reprezentálhatjuk.
	Az útkeresési probléma és a megoldás között található a keresés. A keresésbe tartoznak a lokális keresések, a visszalépéses keresések, a gráfkeresések, az evolúciós algoritmus, a rezolúció és a szabályalapú következtetés.\\
	
	\subsection{Mire kell a modellezésnek fókuszálni}
	Problématér elemei: probléma lehetséges válaszai.\\
	Cél: egy helyes válasz (megoldás) megtalálása\\
	Keresést segítő ötletek (heurisztikák): \\
	-Problématér hasznos elemeinek elválasztása a haszontalanoktól.\\
	-Az elemek szomszédsági kapcsolatainak kijelölése, hogy a probléma tér elemeinek szisztematikus bejárását segítsük.\\
	-Adott pillanatban elérhető elemek rangsorolása.\\
	-Kiinduló elem kijelölése.\\
	
	\subsection{Útkeresési probléma}
	Egy útkeresési problémában a problématér elemeit egy olyan élsúlyozott irányított gráf csúcsai vagy útjai szimbolizálják, amelyik gráf nem feltétlenül véges, de a csúcsainak kifoka véges, és van egy közös pozitív alsó korlátja az élek súlyának (költségének) ($\delta$-gráf).\\
	A megoldást ennek megfelelően vagy egy célcsúcs, vagy egy startcsúcsból célcsúcsba vezető út (esetleg a legolcsóbb ilyen) megtalálása szolgáltatja.\\
	Számos olyan modellező módszert ismerünk, amely a kitűzött feladatot útkeresési problémává fogalmazza át.
	
	\subsection{Gráf fogalmak}
	-csúcsok, irányított élek:$\rightarrow$ N, A $\subseteq$ NxN\\
	-él n-ből m-be $\rightarrow$ (n,m) $\in$ A (n,m $\in$ N)\\
	-n utódai $\rightarrow$ $\gamma$ (n) = $\{$ m $\in$ N $\mid$ (n,m) $\in$ A $\}$\\
	-n szülei $\rightarrow$ $\pi$(n) $\in$ $\Pi$(n) = $\{$ m $\in$ N $\mid$ (m,n) $\in$ A $\}$\\
	-irányított gráf $\rightarrow$ R=(N,A)\\
	-véges sok kivezető él $\rightarrow$ $\mid$ $\gamma$ (n) $\mid$ $<$ $\infty$ ($\forall$ n $\in$ N)\\
	-élköltség $\rightarrow$ c:A $\rightarrow$ ${\rm I\!R}$\\
	-$\delta$ tulajdonság ($\delta$$\in$${\rm I\!R^+}$) $\rightarrow$ c(n,m) $\geq$ $\delta$ $>$ 0 ($\forall$(n,m)$\in$A)\\
	-$\delta$-gráf $\rightarrow$ $\delta$-tulajdonságú, véges sok kivezető élű, élsúlyozott irányított gráf\\
	-irányított út $\rightarrow$ $\alpha$ = (n,$n_1$),($n_1$,$n_2$),...,(n$\textsubscript{k-1}$,m) = $<$n,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m$>$ n$\rightarrow$$\textsuperscript{$\alpha$}$m, n$\rightarrow$ m, n$\rightarrow$M (M $\subseteq$ N) {n$\rightarrow$m}, {n$\rightarrow$M}\\
	-út hossza $\rightarrow$ az út éleinek száma: $|$$\alpha$$|$\\
	-út költsége $\rightarrow$ c($\alpha$)=c$\textsuperscript{$\alpha$}$(n,m) :=  $\sigma$$\textsubscript{j=1..k}$c(n$\textsubscript{j-1}$,$n_j$) ha $\alpha$ = $<$n=$n_0$,$n_1$,$n_2$,...,n$\textsubscript{k-1}$,m=$n_k$$>$\\
	-opt. költség $\rightarrow$ c*(n,m):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,m) $\{$$\delta$ gráfokban ez végtelen sok út esetén is értelmes. Értéke $\infty$, ha nincs egy út se.$\}$ \\
	-opt. költség2 $\rightarrow$ c*(n,M):=min$\textsubscript{$\alpha$ $\in$ $\{$ n $\rightarrow$ m $\}$ }$c$\textsuperscript{$\alpha$}$(n,M) \\
	-opt. költségű út n$\rightarrow$*m :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$m$\}$ $\}$ \\
	-opt. költségű út n$\rightarrow$*M :=$min_c$$\{$$\alpha$$|$ $\alpha$$\in$$\{$n$\rightarrow$M$\}$ $\}$ \\
	
	\subsection{Gráfreprezentáció fogalma}
	Minden útkeresési probléma rendelkezik egy (a probléma modellezéséből származó) gráfreprezentációval, ami egy (R,s,T) hármas, amelyben:\\
	-R=(N,A,c) $\delta$-gráf az ún. reprezentációs gráf,\\
	-az s$\in$N startcsúcs,\\
	-a T$\subseteq$N halmazbeli célcsúcsok.\\
	És a probléma megoldása:\\
	-egy t$\in$T cél megtalálása, vagy\\
	-egy s$\rightarrow$T, esetleg s$\rightarrow$*T optimális út megtalálása\\
	(s-ből Tegyik csúcsába vezető irányított út, vagy s-ből T egyik csúcsába vezető legolcsóbb irányított út)\\
	Az útkeresési problémák megoldásáshoz azok a reprezentációs gráfjainak nagy mérete miatt speciális (nem determinisztikus, heurisztikus) útkereső algoritmusokra van szükség, amelyek:\\
	-a startcsúcsból indulnak, amely az első aktuális csúcs;\\
	-minden lépésben nem-determinisztikus módon új aktuális csúcso(ka)t választanak a korábbi aktuális csúcs(ok) alapján (gyakran azok gyerekei közül);\\
	-tárolják a már feltárt reprezentációs gráf egy részét;\\
	-megállnak, ha célcsúcsot találnak vagy nyilvánvalóvá válik, hogy erre semmi esélyük.\\
	
	\subsection{Kereső rendszer (KR)}
	Procedure KR\\
	1. ADAT:= kezdeti érték\\
	2. while !terminálási feltétel(ADAT) loop\\
	3. \quad SELECT SZ FROM alkalmazható szabályok\\
	4. \quad ADAT := SZ(ADAT)\\
	5. endloop\\
	end\\
	AHOL:\\
	-ADAT: globális munkaterület, tárolja a keresés során megszerzett és megőrzött ismeretet\\
	-alkalmazható szabályok: keresési szabályok, megváltoztatják a globális munkaterület tartalmát\\
	-SELECT: vezérlési stratégia, alkalmazható szabályok közül kiválaszt egy "megfelelőt"
	
	\subsection{Kereső rendszerek vizsgálata}
	-helyes-e (azaz korrekt választ ad-e)\\
	-teljes-e (minden esetben választ ad-e)\\
	-optimális-e(optimális megoldást ad-e)\\
	-idő bonyolultság\\
	-tár bonyolultság\\
	
	\section{GÉPI TANULÁS}
	-Egy programozási feladat megoldásához meg kell adnunk a feladat modelljét és készítenünk kell egy ehhez illeszkedő algoritmust, amely a feladat megoldását előállítja.\\
	-Gépi tanulással a modell (reprezentáció és/vagy heurisztika), illetve a megoldó algoritmus (többnyire annak bizonyos paraméterei) állhatnak elő automatikusan.\\
	-A tanuláshoz a megoldandó probléma néhány konkrét esetére, a tanító példákra van szükség.\\
	-A gépi tanulási módszereket három csoportba szokás sorolni: felügyelt-, nem-felügyelt, és megerősítéses tanulásra attól függően, hogy a tanító példák input-output párok, csak inputok, vagy input-hasznosság párok.\\
	
	\section{Állapottér-reprezentáció}
	\underline{Állapottér}: a probléma leírásához szükséges adatok által felvett érték-együttesek (azaz állapotok) halmaza\\
	-az állapot többnyire egy összetett szerkezetű érték\\
	-gyakran egy bővebb alaphalmazzal és egy azon értelmezett invariáns állítással definiáljuk\\
	\underline{Múveletek}: állapotból állapotba vezetnek.\\
	-megadásukhoz: előfeltétel és hatás leírása\\
	-invariáns tulajdonságot tartó leképezés\\
	\underline{Kezdőállapot(ok)} vagy azokat leíró kezdeti feltétel\\
	\underline{Végállapot(ok)} vagy célfeltétel
	
	\subsection{Hanoi tornyai probléma}
	
	\underline{Állapottér:}
	AT=$\{$1,2,3$\}$\textsuperscript{n}\\
	megjegyzés: a tömb i-dik eleme mutatja az i-dik korong rúdjának számát, a korongok a rudakon méretük szerint fentről lefelé növekvő sorban vannak.\\	
	\underline{Művelet:}Rak(honnan,hova): AT$\rightarrow$AT honnan, hova $\in$ \{1,2,3\}\\
	HA a honnan és hova \underline{létezik} és \underline{nem azonos}, és \underline{van korong} a honnan rúdon, és a hova rúd \underline{üres} vagy a mozgatandó korong (honnan rúd felső korongja) \underline{kisebb}, mint a hova rúd felső korongja, AKKOR this[honnan legfelső korongja] := hova
	
	\subsection{Állapottér-reprezentáció gráf-reprezentációja}
	\underline{$\delta$-gráf} ~ állapot-gráf\\
	-csúcs: állapot\\
	-irányított él: művelet hatása\\
	-élköltség: művelet költsége\\
	\underline{startcsúcs} ~ kezdőállapot\\
	\underline{célcsúcsok} ~ végállapotok\\
	\underline{irányított út} ~ egy műveletsorozat hatása\\
	
	\subsection{Állapottér vs. problématér}
	-Az állapottér-reprezentáció és a problématér között szoros kapcsolat áll fenn, de az állapottér többnyire nem azonos a problématérrel.\\
	-A problématér elemeit többnyire nem az állapotok, hanem a startcsúcsból induló különböző hosszúságú irányított utak.\\
	\hspace*{1em} -A hanoi tornyai problémánál például egy megoldást egy irányított út\\ \hspace*{1em} szimbolizál, amelyik a startcsúcsból a célcsúcsba vezet.\\
	\hspace*{1em} -Van amikor a megoldás egyetlen álapot (azaz csúcs), de ebben az esetben is\\ \hspace*{1em} kell találni egy odavezető operátor-sorozatot (azaz irányított utat).
	 
	 \subsection{Állapot-gráf bonyolultsága}
	 Állapot-gráf bonyolultsága $\rightarrow$ Problématér mérete $\rightarrow$ Keresés számításigénye\\ \\
	 A bonyolultság elsősorban a start csúcsból kivezető utak száma az oda-vissza lépések nélkül, amely nyilván függvénye a\\
	 \hspace*{1em} -csúcsok és élek számának\\
	 \hspace*{1em} -csúcsok ki-fokának\\
	 \hspace*{1em} -körök gyakoriságának, és hosszuk sokféleségének\\ \\
	 Ugyanannak a feladatnak több modellje lehet: érdemes olyat keresni, amely kisebb problémateret jelöl ki.\\
	 \hspace*{1em} -Az előző reprezentációnál a problématér mérete, azaz a lehetséges utak \\ \hspace*{1em}száma, óriási. Készítsünk jobb modellt!\\
	 \hspace*{1em}-Bővítsük az állapotteret, és használjunk új műveletet!\\
	 \hspace*{1em}-Műveletek előfeltételének szigorításával csökken az állapot-gráf átlagos ki-foka.
	 
	 \subsection{Művelet végrehajtásának hatékonysága}
	 A művelet kiszámítási bonyolultsága csökkenthető, ha az állapotokat extra információval egészítjük ki, vagy az invariáns szigorításával szűkítjük az állapotteret. \\ 
	 
	 \subsection{Hogyan "látja" egy keresés a reprezentációs gráfot?}
	 Egy keresés fokozatosan fedezi fel a reprezentációs gráfot:
	 bizonyos részeihez soha nem jut el, de a felfedezett részt sem feltétlenül tárolja el teljesen, sőt, sokszor torzultan "látja" azt: ha például egy csúcshoz érve nem vizsgálja meg, hogy ezt korábban már felfedezte-e, hanem új csúcsként regisztrálja, akkor az eredeti gráf helyett egy fát fog tárolni.
	 
	 \subsection{Reprezentációs gráf "fává egyenesítése"}
	 Ha a keresés nem vizsgálja meg egy csúcsról, hogy korábban már felfedezte-e, akkor az eredeti reprezentációs gráf helyett annak fává kiegyenesített változatában keres.\\
	 Előny: eltűnnek a körök, de a megoldási utak megmaradnak.\\
	 Hátrány: duplikátumok jelennek meg, sőt a körök kiegyenesítése végtelen hosszú utakat eredményez.\\
	 A kétirányú (oda-vissza) élek szörnyen megnövelik a kiegyenesítéssel kapott fa méretét. De bármelyik keresésnél eltárolhatjuk egy csúcsnak azt a szülőcsúcsát, amelyik felől a csúcsot elértük. Így egy csúcsból a szülőjébe visszavezető él könnyen felismerhető és figyelmen kívül hagyható.
	 
	 \section{Probléma dekompozíció}
	 Egy probléma dekomponálása során a problémát részproblémákra bontjuk, majd azokat tovább részletezzük, amíg nyilvánvalóan megoldható problémákat nem kapunk.\\
	 Sokszor egy probléma megoldását akár többféleképpen is fel lehet bontani részproblémák megoldásaira.
	 
	 \subsection{Dekompozíciós reprezentáció fogalma}
	 A reprezentációhoz meg kell adnunk:\\
	 -a feladat részproblémáinak általános leírását\\
	 -a kiinduló problémát\\
	 -az egyszerű problémákat, amelyekről könnyen eldönthető, hogy megoldhatók-e vagy sem\\
	 -a dekomponáló műveleteket:\\
	 \hspace*{1em}D: probléma $\rightarrow$ probléma$\textsuperscript{+}$\\
	 \hspace*{1em}D(p)= $<$p$\textsubscript{1}$,...,p$\textsubscript{n}$$>$
	 
	 \subsection{A dekompozíció modellezése ÉS/VAGY gráffal}
	 Egy dekompozíciót egy ún. ÉS/VAGY gráffal szemléltetjük:
	 -egy csúcs egy részproblémát jelöl, a startcsúcs a kiinduló problémát, a célcsúcsok a megoldható egyszerű problémákat.
	 -egy élköteg egy dekomponáló művelet hatását írja le, és a dekomponált probléma csúcsából a dekomponálással előállított részproblémák csúcsaiba vezet.\\
	 \hspace*{1em}- egy élköteg élei mutatják meg, hogy a dekomponált probléma megoldásához\\
	 \hspace*{1em}  mely részproblémákat kell megoldani. Az élköteg élei között ezért ún. "ÉS"\\
	 \hspace*{1em}  kapcsolat van: hiszen minden részproblémát meg kell oldani.\\
	 \hspace*{1em}- egy csúcsból több élköteg is indulhat, ha egy probléma többféleképpen\\
	 \hspace*{1em} dekomponálható. Ezen élkötegek élei között ún. "VAGY" kapcsolat áll fenn:\\
	 \hspace*{1em} hiszen választhatunk, hogy melyik élköteg mentén oldjunk meg egy problémát.
	 
	 \subsection{ÉS/VAGY gráfok}
	 1. AZ R=(N,A) élsúlyozott irányított hiper-gráf, ahol az\\
	 \hspace*{1em}-N a csúcsok halmaza\\
	 \hspace*{1em}-A $\subseteq$ \{ (n,M)$\in$ NxN$\textsuperscript{+}$ $|$ 0$\neq$$|$M$|$ $<$ $\infty$ \} a hiper-élek halmaza, $|$M$|$ a hiper-él\\
	 \hspace*{1em} rendje\\
	 \hspace*{1em}-(c(n,M) az (n,M) költsége)\\
	 2. Egy csúcsból véges sok hiper-él indulhat\\
	 3. (0$<$$\delta$$\leq$c(n,M))
	 
	 \subsection{Megoldás-gráf}
	 Az eredeti problémát egyszerű problémákra visszavezető dekomponálási folyamatot az ÉS/VAGY gráf speciális részgráfja, az ún. megoldás-gráf jeleníti meg, amelyben:\\
	 \hspace*{1em} -szerepel a startcsúcs\\
	 \hspace*{1em} -a startcsúcsból minden más csúcsba vezet út, és minden csúcsból vezet út\\
	 \hspace*{1em} egy megoldás-gráfbeli célcsúcsba\\
	 \hspace*{1em} -egy éllel együtt az összes azzal "ÉS" kapcsolatban álló él is (azaz a teljes\\
	 \hspace*{1em} élköteg) része a megoldás-gráfnak\\
	 \hspace*{1em} -nem tartalmaz "VAGY" kapcsolatban álló él párokat\\
	 A megoldás a megoldás-gráfból olvasható ki.
	 
	 \subsection{Az n csúcsból az M csúcs-sorozatba vezető irányított hiper-út fogalma}
	 Az n$\textsuperscript{$\alpha$}$$\rightarrow$M hiper-út (n$\in$N,M$\in$N$\textsuperscript{+}$) egy olyan véges részgráf, amelyben:\\
	 \hspace*{1em}-M csúcsaiból nem indul hiper-él\\
	 \hspace*{1em}-M-en kívüli csúcsokból csak egy hiper-él indul\\
	 \hspace*{1em}-minden csúcs elérhető az n csúcsból egy közönséges irányított úton.\\
	 A megoldás-gráf egy olyan hiper-út, amely a startcsúcsból csupa célcsúcsba vezet.
	 
	 \subsection{Hiper-út bejárása}
	 Az n$\rightarrow$M hiper-út egy bejárásán a hiper-út csúcsaiból képzett sorozatoknak a felsorolását értjük:\\
	 \hspace*{1em} -első sorozat: $<$n$>$\\
	 \hspace*{1em} -a C sorozatot a C$\textsuperscript{k$\leftarrow$K}$ sorozat követi (ahol a k$\in$C, és\\
	 \hspace*{1em} k minden C-beli előfordulásának helyén a K sorozat szerepel) feltéve, hogy a\\
	 \hspace*{1em} hiper-útnak van olyan (k,K) hiper-éle, ahol k$\notin$M.\\
	 
	 \subsection{Útkeresés ÉS/VAGY gráfban}
	 Amikor a startcsúcsból induló hiper-utakat (ezek között vannak a megoldás-gráfok is, ha egyáltalán vannak ilyenek) a bejárásukkal írjuk le, akkor ezek a bejárások olyan közönséges irányított utak, amelyek csúcsai az eredeti ÉS/VAGY gráf csúcsainak sorozatai. Ezen utakból egy olyan közönséges irányított gráfot készíthetünk, amelyben a startcsúcs az ÉS/VAGY gráf startcsúcsából álló egy elemű sorozat, a célcsúcsait leíró sorozatok pedig kizárólag az ÉS/VAGY gráf célcsúcsainak egy részét tartalmazzák.\\
	 Ha ebben a közönséges gráfban megoldási utat találunk, akkor az egyben az eredeti ÉS/VAGY gráf megoldás-gráfja is lesz.
	 
	 
	 \section{Keresések}
	 
	 \subsection{KR vezérlési szintjei}
	 Három féle vezérlési stratégiát különböztetünk meg:\\
	 -általános (független a feladattól, és annak modelljétől: nem merít sem a feladat\\ \hspace*{0,2em}ismereteiből, sem a modell sajátosságaiból.)\\
	 -modellfüggő (nem függ a feladat ismereteitől, de épít a feladat modelljének\\
	 \hspace*{0,2em} általános elemeire.)\\
	 -heurisztikus (a feladattól származó, annak modelljében nem rögzített, a megoldást\\
	 \hspace*{0,2em} segítő speciális ismeret)
	 
	 Másik megközelítés alapján, kétféle általános stratégiát különböztetünk meg:\\
	 -nemmódosítható (lokális keresések, evolúciós algoritmus, rezolúció)\\
	 -módosítható (visszalépéses keresések, gráfkeresések)
	 
	 \subsection{Lokális keresések}
	 A lokális keresés olyan KR, amely a probléma reprezentációs gráfjának egyetlen csúcsát (aktuális csúcs) és annak szűk környezetét tárolja (a globális munkaterületén).\\
	 Kezdetben az aktuális csúcs a startcsúcs, és a keresés akkor áll le, ha az aktuális csúcs a célcsúcs lesz.\\
	 Az aktuális csúcsot minden lépésben annak környezetéből vett "jobb" csúccsal cseréli le (keresési szabály).\\
	 A "jobbság" eldöntéséhez (vezérlési stratégia) egy kiértékelő (cél-,\\ rátermettségi-, heurisztikus) függvényt használ, amely reményeink szerint annál jobb értéket ad egy csúcsra, minél közelebb esik az a célhoz.
	 
	 \subsection{Hegymászó algoritmus}
	 Mindig az aktuális (akt) csúcs legjobb gyermekére lép, amelyik lehetőleg nem a szülője.\\
	 (Megjegyzés: Az eredeti hegymászó algoritmus nem zárja ki a szülőre való lépést, viszont nem engedi meg, hogy az aktuális csúcsot egy rosszabb értékű csúcsra cseréljük, ilyenkor inkább leáll.)\\
	 \underline{Hátrányok:}\\
	 Csak erős heurisztika esetén lesz sikeres: különben "eltéved" (nem talál megoldást), sőt zsákutcába jutva "beragad".\\
	 Segíthet, ha:\\
	 \hspace*{0,5em} -véletlenül választott startcsúcsból újra- és újra elindítjuk (random restart\\ \hspace*{1,1em}local search)\\
	 \hspace*{0,5em} -k darab aktuális csúcs legjobb k darab gyerekére lépünk (local beam search)\\
	 \hspace*{0,5em} -gyengítjük a mohó stratégiáját (simulated annealing)\\
	 Lokális optimum hely körül vagy ekvidisztans felületen (azonos értékű szomszédos csúcsok között) található körön, végtelen működésbe eshet.\\
	 Segíthet ha:\\
	 \hspace*{0,5em} -növeljük a memóriát (tabu search)\\ \\
	 
	 \subsection{Tabu keresés}
	 A globális munkaterületén az aktuális csúcson (akt) kívül nyilvántartja még:\\
	 \hspace*{0,5em} -az utolsó néhány érintett csúcsot: Tabu halmaz\\
	 \hspace*{0,5em} -az eddigi legjobb csúcsot: optimális csúcs (opt)\\ \\
	 Egy keresési szabály minden lépésben\\
	 \hspace*{0,5em} -az aktuális csúcsnak a legjobb, de nem a Tabu halmazban lévő gyerekére lép\\
	 \hspace*{0,5em} -ha akt jobb, mint az opt, akkor opt az akt lesz\\
	 \hspace*{0,5em} -frissíti akt-tal a sorszerkezetű Tabu halmazt\\ \\
	 Terminálási feltételek:\\
	 \hspace*{0,5em} -ha az opt a célcsúcs\\
	 \hspace*{0,5em} -ha az opt sokáig nem változik \\ \\
	 \underline{Előnyök:}\\
	 Tabu méreténél rövidebb köröket észleli, és ez segíthet a lokális optimum hely illetve az ekvidisztans felület körüli körök leküzdésében.\\ \\
	 \underline{Hátrányok:}
	 A tabu halmaz méretét kísérletezéssel kell belőni. \\
	 Zsákutcába futva nem-módosítható stratégia miatt beragad.
	 
	 \subsection{Szimulált hűtés}
	 A keresési szabály a következő csúcsot véletlenszerűen választja ki az aktuális (akt) csúcs gyermekei közül.\\
	 Ha az így kiválasztott új csúcs kiértékelő függvény-értéke nem rosszabb, mint az akt csúcsé (itt f(új) $\leq$ f(akt)), akkor elfogadjuk aktuális csúcsnak.\\
	 Ha az új csúcs függvényértéke rosszabb (itt f(új) $>$ f(akt)), akkor egy olyan véletlenített módszert alkalmazunk, ahol az új csúcs elfogadásának valószínűsége fordítottan arányos az $|$ f(akt) - f(új) $|$ különbséggel: \\
	 $e^\frac{f(akt)-f(uj)}{T}$ $>$ random[0,1] \\
	 
	 \subsection{Hűtési ütemterv}
	 Egy csúcs elfogadásának valószínűségét az elfogadási képlet kitevőjének T együtthatójával szabályozhatjuk. Ezt egy (T$\textsubscript{k}$,L$\textsubscript{k}$) k=1,2,... ütemterv vezérli, amely L$\textsubscript{1}$, majd L$\textsubscript{2}$ lépésen keresztül T$\textsubscript{2}$, stb. lesz.\\
	 $e^\frac{f(current)-f(new)}{T_k}$ $>$ rand[0,1]\\
	 Ha $T_1$, $T_2$, ... szigorúan monoton csökken, akkor egy ugyanannyival rosszabb függvényértékű új csúcsot kezdetben nagyobb valószínűséggel fogad el a keresés, mint később.
	 
	 \subsection{Lokális kereséssel megoldható feladatok}
	 Erős heurisztika nélkül nincs sok esély a cél megtalálására.\\
	 \hspace*{0,5em} -Jó heurisztikára épített kiértékelő függvénnyel elkerülhetőek a zsákutcák,\\
	 \hspace*{0,5em} a körök.\\
	 A sikerhez az kell, hogy egy lokálisan hozott rossz döntés ne zárja ki a cél megtalálását!\\
	 \hspace*{0,5em} -Ez például egy erősen összefüggő reprezentációs-gráfban automatikusan \\
	 \hspace*{1em}teljesül, de kifejezetten előnytelen, ha a reprezentációs-gráf egy irányított fa. (Például az n-királynő problémákat csak tökéletes kiértékelő függvény esetén lehetne lokális kereséssel megoldani.)
	 
	 \subsection{A heurisztika hatása a KR működésére}
	 A heurisztika olyan, a feladathoz kapcsolódó ötlet, amelyet közvetlenül építünk be egy algoritmusba azért, hogy annak eredményessége és hatékonysága javuljon ( egyszerre képes javítani a futási időt és a memóriaigényt), habár erre általában semmiféle garanciát nem ad.
	 
	 \section{Visszalépéses keresés}
	 A visszalépéses keresés egy olyan KR, amely:\\
	 \hspace*{1em} -globális munkaterülete:\\
	 \hspace*{2em} egy út a startcsúcsból az aktuális csúcsba (ezen kívül az útról leágazó \\
	 \hspace*{2em} még ki nem próbált élek)\\
	 \hspace*{3em} kezdetben a startcsúcsot tartalmazó nulla hosszúságú út\\
	 \hspace*{3em} terminálás célcsúccsal vagy startcsúcsból való visszalépéssel\\
	 \hspace*{1em} -keresés szabályai:\\
	 \hspace*{2em} a nyilvántartott út végéhez egy új (ki nem próbált) él hozzáfűzése, vagy\\
	 \hspace*{2em} a legutolsó él törlése (visszalépés szabálya)\\
	 \hspace*{1em} -vezérlés stratégiája a visszalépés szabályát csak a legvégső esetben\\
	 \hspace*{1em}  alkalmazza\\
	 
	 \subsection{Visszalépés feltételei}
	 -Zsákutca: az aktuális csúcsból (azaz az aktuális út végpontjából) nem vezet\\
	 \hspace*{1em} tovább él\\
	 -Zsákutca torkolat: az aktuális csúcsból kivezető utak nem vezettek célba\\
	 -Kör: az aktuális csúcs szerepel már korábban is az aktuális úton\\
	 -Mélységi korlát: az aktuális út hossza elér egy előre megadott értéket
	 
	 \newpage
	 \subsection{Alacsonyabb rendű vezérlési stratégiák}
	 -A vezérlési stratégia kiegészíthető:\\
	 \hspace*{1em} -sorrendi szabállyal: sorrendet ad az aktuális út végpontjából kivezető \\
	 \hspace*{2em} élek (utak) vizsgálatára\\
	 \hspace*{1em} -vágó szabállyal: megjelöli azokat az aktuális út végpontjából kivezető \\
	 \hspace*{2em} éleket (utakat), amelyeket nem érdemes megvizsgálni\\
	 -Ezek a szabályok lehetnek:\\
	 \hspace*{1em} -másodlagos vezérlési stratégiák (a probléma modelljének sajátosságaiból \\
	 \hspace*{2em} származó ötlet)\\
	 \hspace*{1em} -heurisztikák (a probléma ismereteire támaszkodó ötlet)\\
	 
	 \subsection{Első változat: VL1}
	 A visszalépéses algoritmus első változata az, amikor a visszalépés feltételei közül az első kettőt építjük be a kereső rendszerbe.\\
	 Bebizonyítható: Véges körmentes irányított gráfokon a VL1 mindig terminál, és ha létezik megoldás, akkor talál egyet. UI: véges sok adott startból induló út van.\\
	 Rekurzív algoritmussal (VL1) szokták megadni.
	 
	 \subsection{Az n-királynő probléma új reprezentációs modellje}
	 Az előző módszerek átalakították az n-királynő probléma reprezentációját:\\
	 \hspace*{1em} Tekintsük a $D_1$,...,$D_n$ halmazokat, ahol $D_i$={1...n} \\
	 \hspace*{1em} (ezek az i-dik sor szabad mezői).\\
	 \hspace*{1em} Keressük azt az ($x_1$,...,$x_n$) $\in$ $D_1$ x ... x $D_n$ elhelyezést ($x_i$ az i-dik sorban\\
	 \hspace*{1em} elhelyezett királynő oszloppozíciója),\\
	 \hspace*{1em} amely nem tartalmaz ütést: minden i,j királynő párra:\\
	 \hspace*{1em} C$\textsubscript{ij}$($x_i$,$x_j$) $\equiv$ ($x_i$$\neq$$x_j$ $\bigwedge$ $|$$x_i$-$x_j$$|$$\neq$$|$i-j$|$).\\
	 A visszalépéses keresés e modell változóinak értékeit határozza meg, miközben a bemutatott vágó módszerek egyike redukálják ezen változók $D_i$ halmazait.
	 
	 \subsection{Bináris korlát-kielégítési modell}
	 Keressük azt az ($x_i$,...,$x_n$) $\in$ $D_1$ x...x$D_n$ n-est ($D_i$ véges) amely kielégít néhány C$\textsubscript{ij}$$\subseteq$ $D_i$x$D_j$ bináris korlátot.\\
	 Példa:\\
	 Házasságközvetítő probléma (n férfi, m nő, keressünk minden férfinak neki szimpatikus feleségjelöltet):\\
	 \hspace*{1em} -Az i-dik férfi (i=1..n) felesége ($x_i$) a $D_i$={1,...,m} azon elemei, amelyekre fenn \\
	 \hspace*{2em} áll, hogy szimpatikus(i,$x_i$).\\
	 \hspace*{1em} -Az összes (i,j)-re: C$\textsubscript{ij}$($x_i$,$x_j$) $\equiv$ ($x_i$,$x_j$) (azaz nincs bigámia)
	 
	 \subsection{Modellfüggő vezérlési stratégia}
	 A korábban mutatott vágó módszereket az új modellben a bináris korlátok definiálják, de a korlátok jelentésétől függetlenül. Ezek a módszerek tehát nem heurisztikák, hanem modellfüggő vágó stratégiák:\\
	 \hspace*{1em} Töröl(i,k): $D_i$:= $D_i$- \{ e$\in$$D_i$$|$ $\neg$C$\textsubscript{ik}$(e,$x_k$)\}\\
	 \hspace*{1em} Szűr(i,j) :$D_i$:=  $D_i$ - \{ e$\in$$D_i$ $|$ $\forall$f$\in$$D_j$:$\neg$C$\textsubscript{ij}$(e,f)\}\\
	 Modellfüggő sorrendi stratégiák is konstruálhatók:\\
	 \hspace*{1em} -Mindig a legkisebb tartományú még kitöltetlen komponensek válasszunk\\
	 \hspace*{2em} előbb értéket.\\
	 \hspace*{1em}- Ugyanazon korláthoz tartozó komponenseket lehetőleg közvetlenül egymás\\
	 \hspace*{2em} után töltsük ki.\\
	 
	 \subsection{Második változat: VL2}
	 A visszalépéses algoritmus második változata az, amikor a visszalépés feltételei közül mindet beépítjük a kereső rendszerbe.\\
	 Bebizonyítható: A VL2 $\delta$-gráfban mindig terminál. Ha létezik a mélységi korlátnál nem hoszabb megoldás, akkor megtalál egy megoldást. UI: véges sok adott korlátnál rövidebb startból induló út van.\\
	 Rekurzív algoritmussal (VL2) adjuk meg\\ \\
	 1: akt := utolsó\textunderscore csúcs(út) \\
	 2: if cél(akt) then return(nil) endif \\
	 3: if hossza(út) $\geq$ korlát then return(hiba) endif
	 4: if akt $\in$ maradék(út) then return(hiba) endif \\
	 5: for $\forall$új $\in$ $\gamma$(akt) - $\pi$(akt) loop \\
	 6: \hspace{1em} megoldás:= VL2(fűz(út,új)) \\
	 7: \hspace{1em} if megoldás $\neq$ hiba then  \\
	 8: \hspace{2em} return(fűz((akt,új),megoldás)) endif \\
	 9: endloop \\
	 10:return (hiba) \\
	 
	 \subsection{Mélységi korlát szerepe}
	 A VL2 nm talál megoldást (csak terminál), ha a megadott mélységi korlátnál csak hosszabb megoldási utak vannak. \\
	 A mélységi korlát önmagában is biztosítja a terminálást körök esetén is. \\
	 - Ez akkor előnyös, ha nincsenek rövid körök ( a kettő hosszú köröket kiszűri a szülőcsúcs vizsgálat).\\
	 -Ilyenkor nem kell a rekurzív hívásnál a teljes aktuális utat átadni : elég az út hosszát, az aktuális csúcsot és annak szülőjét.
	 
	 \subsection{Értékelés}
	 \underline{Előnyök}: \\
	 -Mindig terminál, talál megoldást (a mélységi korláton belül)\\
	 -Könnyen implementálható \\
	 -Kicsi memória igény \\ \\
	 \underline{Hátrányok}: \\
	 -Nem ad optimális megoldást. (iterációba szervezhető)\\
	 -Kezdetben hozott rossz döntést csak sok visszalépés korrigál (visszaugrásos keresés) \\
	 -Egy zsákutca részt többször is bejárhat a keresés \\
	 
	 \section{Gráfkeresés}
	 A gráfkeresés olyan KR, amelynek:\\
	 \hspace*{1em} -globális munkaetülete: a reprezentációs gráf startcsúcsból kiinduló már\\
	 \hspace*{1em} feltárt útjait tárolja ( tehát egy részgráfot), és külön az egyes utak végeit, \\
	 \hspace*{1em} a nyílt csúcsokat\\
	 \hspace*{2em} -kiinduló értéke: a startcsúcs,\\
	 \hspace*{2em} -terminálási feltétel: megjelenik egy célcsúcs vagy megakad az algoritmus.\\
	 \hspace*{1em} -keresés szabálya: egyik útvégi csúcs kiterjesztése\\
	 \hspace*{1em} -vezérlés stratégiája: a legkedvezőbb csúcs kiterjesztésére törekszik
	 
	 \subsection{Általános gráfkereső algoritmus}
	 Jelölések:\\
	 \hspace*{1em} -keresőgráf (G): a reprezentációs gráf eddig bejárt és eltárolt része\\
	 \hspace*{1em}-nyílt csúcsok halmaza (NYÍLT): kiterjesztésre várakozó csúcsok, amelyeknek\\
	 \hspace*{1em} gyerekeit még nem vagy nem eléggé jól ismerjük. \\
	 \hspace*{1em} -kiterjesztett csúcsok halmaza (ZÁRT) : azok a csúcsok, amelyeknek a \\
	 \hspace*{1em} gyerekeit már előállítottuk.\\
	 \hspace*{1em} -kiértékelő függvény (f: NYÍLT $\rightarrow$  ${\rm I\!R}$): kiválasztja a megfelelő nyílt csúcsot \\
	 \hspace*{1em}kiterjesztésre
	 
	 \subsection{Kritika}
	 -Nem olvasható ki a megoldási út a kereső gráfból\\
	 \hspace*{1em} -Meg kell jegyezni a felfedezett utak nyomát.\\
	 Nem garantál optimális megoldást (sőt még a megoldást sem)\\
	 \hspace*{1em} -Tároljuk el egy csúcsnál az odavezető eddig talált legjobb út költségét.\\
	 Körökre érzékeny\\
	 \hspace*{1em} -Ha ehhez a csúcshoz egy kört tartalmazó utat találunk, akkor annak költsége\\
	 \hspace*{1em}  drágább lesz a tárolt értéknél, hiszen $\delta$-gráfban vagyunk.
	 
	 \subsection{Gráfkeresés függvényei}
	 $\pi$(n)= N$\rightarrow$ N szülőre visszamutató pointer \\
	 \hspace*{1em} $\pi$ (n)=n csúcs már ismert szülője, $\pi$(start)=nil\\
	 \hspace*{2em} $\pi$ egy start gyökerű irányított feszítőfát jelöl ki G-ben: $\pi$ feszítőfa, $\pi$-út \\
	 \hspace*{2em} Jó lenne, ha a $\pi$-út optimális start$\rightarrow$n G-beli utat jelölne ki: a $\pi$ feszítőfa\\
	 \hspace*{2em} optimális lenne. \\
	 g: N$\rightarrow$${\rm I\!R}$ költség függvény\\
	 \hspace*{1em} g(n)=c$\textsuperscript{$\alpha$}$(start,n) - egy már megtalált $\alpha$$\in$ {start $\rightarrow$n} út költsége\\
	 \hspace*{1em} Jó lenne ha minden n-re a g(n) a $\pi$-út költségét mutatná, azaz a $\pi$ és\\
	 \hspace*{1em} g konzisztens lenne.
	 
	 \subsection{A korrektség fenntartása}
	 Kezdetben: $\pi$(start) :=nil, g(start) :=0\\
	 Az n csúcs kiterjesztése után minden m$\in$$\gamma$(n) csúcsra\\
	 \hspace*{1em} 1. Ha m új csúcs\\
	 \hspace*{2em} azaz m$\notin$G akkor\\
	 \hspace*{3em} $\pi$(m) :=n, g(m) := g(n)+c(n,m)\\
	 \hspace*{3em} NYÍLT := NYÍLT $\cup$ {m}\\
	 \hspace*{1em} 2. Ha m régi csúcs, amelyhez olcsóbb utat találtunk\\
	 \hspace*{2em} azaz m $\in$ G és g(n) + c(n,m) $<$ g(m) akkor\\
	 \hspace*{3em} $\pi$(m) :=n, g(m) :=g(n)+c(n,m) //g(n) értéke ekkor csökken\\
	 \hspace*{1em} 3. Ha m régi csúcs, amelyhez nem találtunk olcsóbb utat\\
	 \hspace*{2em} azaz m$\in$G és g(n) + c(n,m)  $\geq$g(m) akkor SKIP\\
	 
	 \subsection{Általános gráfkereső algoritmus}
	 1: G:= ({start}, $\emptyset$);NYÍLT:={start};g(start):=0;$\pi$(start):=nil\\
	 2: loop\\
	 3: \hspace{1em} if empty(NYÍLT) then return nincs megoldás\\
	 4: \hspace{1em} n:=$min_f$(NYÍLT) \\
	 5: \hspace{1em} if cél(n) then return megoldás\\
	 6: \hspace{1em} NYÍLT :=NYÍLT-{n}\\
	 7: \hspace{1em} for $\forall$m$\in$$\delta$(n)-$\pi$(n) loop\\
	 8: \hspace{2em} if(m) $\notin$ G or g(n) + c(n,m) $<$g(m) then\\
	 9: \hspace{3em} $\pi$(m):=n; g(m):=g(n)+c(n,m); NYÍLT :=NYÍLT$\cup${m}\\
	 10:\hspace{1em} endloop\\
	 11:\hspace{1em} G:=G $\cup$ {(n,m)$\in$A $|$ m $\in$$\gamma$(n)-$\pi$(n)}\\
	 12: endloop
	 
	 \subsection{Működés és eredmény}
	 A GK $\delta$-gráfban a működése során egy csúcsot legfeljebb véges sokszor terjeszt ki. (Ebből következik például, hogy körökre nem érzékeny)\\
	 A GK véges $\delta$-gráfban mindig terminál.\\
	 Ha a véges $\delta$-gráfban létezik megoldás, akkor a GK megoldás megtalálásával terminál.\\ \\
	 Egy GK kiértékelő függvénye csökkenő, amennyiben a egy csúcs kiértékelő függvény értéke az algoritmus működése során nem növekszik, viszont mindig csökken, valahányszor a korábbinál olcsóbb utat találunk hozzá. \\
	 Csökkenő kiértékelő függvény mellett a GK időről időre automatikusan helyreállítja a kereső gráf korrektségét, azaz a $\pi$ feszítő fájának optimálisságát és konzisztenciáját.\\
	 
	 \subsection{Nevezetes gráfkereső algoritmusok}
	 Most az f kiértékelő függvény megválasztása következik.\\
	 Nem-informált \hspace{10em} Heurisztikus\\
	 mélységi (MGK) \hspace{10em} előre tekintő (mohó, best-first)\\
	 szélességi (SZGK) \hspace{10em} A, A*, $A^c*$\\
	 egyenletes (EGK) \hspace{10em} A**,B\\
	 
	 \subsection{Heurisztika a gráfkereséseknél}
	 Heurisztikus függvénynek nevezzük azt a h:N$\rightarrow$${\rm I\!R}$ függvényt, amelyik egy csúcsnál megbecsüli a csúcsból a célba vezető ("hátralévő") optimális út költségét.\\
	 h(n) $\approx$ min $\textsubscript{t$\in$T}$c*(n,t) = c*(n,T)=n*(n) (h*:N$\rightarrow$${\rm I\!R}$)\\
	 Ez egy az eddiginél szigorúbb definíciója a heurisztikának.\\
	 
	 \subsection{Heurisztikus függvények tulajdonságai}
	 Nevezetes tulajdonságok:\\
	 Nem-negatív: h(n) $\geq$ 0 $\forall$n$\in$N\\
	 Megengedhető (admissible): h(n) $\leq$h*(n) $\forall$n$\in$N\\
	 Monoton megszorítás: h(n)-h(m) $\leq$c(n,m) $\forall$(n,m)$\in$A (következetes)\\
	 
	 \subsection{A memória igény vizsgálata}
	 $ZART_s$ ~az S gráfkereső algoritmus által lezárt (kiterjesztett csúcsok halmaza)\\
	 Rögzítsünk egy feladatot és két, X ésé Y gráfkereső algoritmust\\
	 Az adott feladatra nézve\\
	 a. az X nem rosszabb az Y-nál, ha $ZART_X$ $\subseteq$$ZART_Y$\\
	 b. az X jobb az Y-nál, ha $ZART_X$ $\subseteq$$ZART_Y$ \\
	 Ezek alapján összevethető\\
	 1. két eltérő heurisztikájú A* algoritmus ugyanazon a feladaton, azaz a két heurisztika.\\
	 2. két útkereső algoritmus, például az A* algoritmus és egy másik szintén optimális megoldást garantáló- gráfkereső algoritmus a megengedhető problémák egy részhalmazán.\\
	 
	 \subsection{Különböző heurisztikájú A* algoritmusok memória igényének összehasonlítása}
	 Az $A_1$ ($h_1$ heurisztikával) és $A_2$ ($h_2$ heurisztikával) A* algoritmusok közül az $A_2$ jobban informált, mint az $A_1$, ha minden n$\in$N$/$ T csúcsra teljesül, hogy $h_1$(n)$<$$h_2$(n).\\
	 Bebizonyítható, hogy a jobban informált $A_2$ nem rosszabb a kevésbé informált $A_1$-nél, azaz ZÁRT$\textsubscript{A2}$ $\subseteq$ ZÁRT$\textsubscript{A1}$
	 
	 \subsection{A futási idő elemzése}
	 Zárt csúcsok száma: k=$|$ZÁRT$|$\\
	 Alsókorlát: k\\
	 \hspace*{1em} Egy monoton megszorításos heurisztika mellett egy csúcs legfeljebb csak\\
	 \hspace*{1em} egyszer terjesztődik ki,\\
	 \hspace*{1em} habár ettől még a kiterjesztett csúcsok száma igen sok is lehet\\
	 \hspace*{1em} (lásd egyenletes keresés)\\
	 Felsőkorlát: 2$\textsuperscript{k-1}$\\
	 \hspace*{1em} lásd. Martelli példáját
	 
	 \subsection{B algoritmus}
	 Martelli javasolta belső kiértékelő függvénynek a g költség függvényt.\\
	 A B algoritmust az A algoritmusból kapjuk úgy, hogy bevezetjük az F aktuális küszöbértéket, majd\\
	 \hspace*{1em} az 1. lépést kiegészítjük az F:= f(s) értékadással,\\
	 \hspace*{1em} a 4. lépést pedig helyettesítjük az \\
	 \hspace*{1em} if min(NYÍLT)$<$F\\
	 \hspace*{2em} then n:= $min_g$(m$\in$NYÍLT $|$ f=(m)$<$F)\\
	 \hspace*{2em} else n:= $min_f$(NYÍLT); F:=f(n)\\
	 \hspace*{1em} endif elágazással.
	 
	 \newpage
	 \subsection{B algoritmus futási ideje}
	 A B algoritmus ugyanúgy működik, mint az A*, azzal a kivétellel, hogy egy árokhoz tartozó csúcsot csak egyszer terjeszt ki.\\
	 Futási idő elemzése:\\
	 \hspace*{1em} Legrosszabb esetben:\\
	 \hspace*{2em} minden zárt csúcs először küszöbcsúcsként terjesztődik ki. \\
	 \hspace*{2em} (Csökkenő kiértékelő függvény mellett egy csúcs csak egyszer, \\
	 \hspace*{2em} a legelső kiterjesztésekor\\
	 \hspace*{2em} lehet köszöb.)\\
	 \hspace*{2em} Az i-dik árok legfeljebb az összes addigi i-1 darab küszöbcsúcsot \\
	 \hspace*{2em} tartalmazhatja ( a start csúcs nélkül).\\
	 \hspace*{1em} Így az összes kiterjesztések száma legfeljebb 1/2x$k^2$
	 
	 \subsection{Heurisztika szerepe}
	 Milyen a jó heurisztika?\\
	 -megengedhető: h(n) $\leq$h*(n)\\
	 \hspace*{1em} Bár nincs mindig szükség optimális megoldásra.\\
	 -jól informált: h(n) ~ h*(n)\\
	 -monoton megszorítás: h(n)-h(m)$\leq$c(n,m)\\
	 \hspace*{1em} Ilyenkor nem érdemes B algoritmust használni\\
	 Változó heurisztikák:\\
	 -f=g+$\phi$xh ahol $\phi$~d\\
	 -B' algoritmus\\ \\
	 if h(n)$<$min\textsubscript{m$\in$$\gamma$(n)}(c(n,m)+h(m))\\
	 then h(n):=min\textsubscript{m$\in$$\gamma$(n)}(c(n,m)+h(m))\\
	 else for $\forall$m$\in$$\gamma$(n)-re loop\\
	 \hspace*{1em} if h(n)-h(m)$>$c(n,m) then h(m):= h(n)-c(n,m)\\
	 \hspace*{1em} endloop\\ \\
	 A h megengedhető marad\\
	 A h nem csökken\\
	 A monoton megszorításos élek száma nő\\
	 
	 \newpage
	 \subsection{Mohó A algoritmus}
	 Nincs mindig szükség az optimális megoldásra. Ilnyekor a mohó A* algoritmus is használható, amely rögtön megáll, ha célcsúcs jelenik meg a NYÍLT-ban.\\
	 Mohó A* algoritmus csak a megoldás megtalálását garantálja. De belátható:\\
	 Ha h megengedhető és $\forall$t$\in$T: $\forall$(n,t)$\in$A:h(n)+$\alpha$ $\geq$c(n,t), akkor a talált megoldás költsége: g(t) $\leq$h*(s)+$\alpha$\\
	 A mohó A* algoritmus megengedhető heurisztika mellett akkor garantálja az optimális megoldást is,\\
	 ha $\forall$ t$\in$T: $\forall$(n,t)$\in$A: h(n)=c(n,t) vagy\\
	 ha h monoton és $\exists$$\alpha$$\geq$0:$\forall$t$\in$T:$\forall$(n,t)$\in$A:h(n)+$\alpha$=c(n,t)
	 
	 \section{Kétszemélyes játékok}
	 \subsection{Kétszemélyees, teljes információjú, véges determinisztikus, zéró összegű játékok}
	 Két játékos lép felváltva adott szabályok szerint, amíga játszma vége nem ér.\\
	 Mindkét játékos ismeri a maga és az ellenfele összes múltbeli és jövőbeli lépéseit és lépési lehetőségeit, és azok következményeit.\\
	 Minden lépés véges számú lehetőség közül választható, és minden játszma véges lépésben véget ér. Egy lépés determinisztikus, a véletlennek nincs szerepe.\\
	 Amennyit a játszma végén az egyik játékos nyer, annyit veszít a másik. (Legegyszerűbb változatban két esélyes: egyik nyer, másik veszít; vagy három esélyes: döntetlen is megengedett)\\
	 
	 \subsection{Állapottér-reprezentáció}
	 állapot \hspace{3em} -állás + soron következő játékos\\
	 művelet \hspace{2,6em} -lépés\\
	 kezdő állapot \hspace{0,6em}-kezdőállás + kezdő játékos\\
	 végállapot \hspace{2em}-végállás + játékos\\
	 payoff függvény: $p_A$,$p_B$: végállapot $\rightarrow$  ${\rm I\!R}$ (játékosok: A,B)\\
	 \hspace*{1em} Zéró összegű kétszemélyes játékban:\\
	 \hspace*{2em} $p_A$(t) + $p_B$(t)=0 minden t végállapotra\\
	 \hspace*{1em} Speciális esetben:\\
	 \hspace*{2em} $p_A$(t)=+1 ha A nyer\\
	 \hspace*{2em} $p_A$(t)=-1 ha A nyer\\
	 \hspace*{2em} $p_A$(t)=0 ha A nyer\\
	 
	 \newpage
	 \subsection{Játékfa}
	 csúcs: állás(egy állás több csúcs is lehet)\\
	 szint: játékos(felváltva az A és B szintjei)\\
	 él: lépés (szintről szintre)\\
	 gyökér: kezdőállás(kezdő játékos)\\
	 levél: végállások\\
	 ág: játszma\\
	 
	 \subsection{Nyerő stratégia}
	 Egy játékos nyerő stratégiája egy olyan elv, amelyet betartva az ellenfél minden lépésére tud olyan választ betartva az ellenfél minden lépésére tud olyan választ adni, hogy megnyerje a játékot.\\
	 A nyerő stratégia NEM egyetlen győztes játszma, hanem olyan győztes játszmák összessége, amelyek közül az egyiket biztos végig tudja játszani az a játékos, aki rendelkezik a nyerő stratégiával.\\
	 Hasznos lehet a nem-vesztő stratégia megtalálása is, ha döntetlent is megengedő játéknál nincs győztes stratégia.\\
	 Általános zéró összegű játékoknál beszélhetünk adott hasznosságot biztosító stratégiáról.
	 TÉTEL:
	 A két esélyes (győzelem vagy vereség) teljes információjú véges determinisztikus kétszemélyes játékokban az egyik játékos számára biztosan létezik nyerő stratégia.\\
	 A három esélyes játékokban (van döntetlen is) a nem vesztő stratégiát lehet biztosan garantálni.\\
	 
	 \subsection{Részleges játékfa-kiértékelés}
	 A nyerő vagy nem-vesztő stratégia megkeresése egy nagyobb játékfa esetében reménytelen.\\
	 Az optimális lépés helyett a soron következő jó lépést keressük. Legyen a bennünket képviselő játékos neve mostantól MAX az ellenfélé pedig MIN.\\
	 Ehhez az aktuális állapotból indulva kell a játékfa néhány szintjét felépíteni, ezen a részfa leveleinek számunkra való hasznosságát megbecsülni, majd ez alapján a soron következő lépést meghatározni.\\
	 
	 \subsection{Kiértékelő függvény}
	 Minden esetben szükségünk van egy olyan heurisztikára, amely a mi szempontunkból becsüli meg egy állás hasznosságát: f: Állások $\Rightarrow$ [-1000, 1000] függvény.\\
	 Példák: \\
	 Sakk: (kiértékelő függvény a fehérnek)\\
	 f(s) = (fehér királynő száma) - (fekete királynő száma)\\
	 Tic-tac-toe: f(s) = M(s) -O(s)\\
	 M(s) = a saját lehetőséges győztes vonalaink száma\\
	 O(s) = az ellenfél lehetséges győztes vonalaink száma\\
	 
	 \subsection{Minimax algoritmus}
	 A játékfának az adott állás csúcsából leágazó részfáját felépítjük néhány szintig\\
	 A részfa leveleit kiértékeljük a kiértékelő függvény segítségével.\\
	 Az értékeket felfuttatjuk a fában:\\
	 \hspace*{1em} A saját (MAX) szintek csúcsaihoz azok gyermekeinek maximumát:\\
	 \hspace*{1em} szülő:= max($gyerek_1$,...,$gyerek_k$)\\
	 \hspace*{1em} Az ellenfél (MIN) csúcsaihoz azok gyermekeinek minimumát:\\ 
	 \hspace*{1em} szülő:=min($gyerek_1$,...,$gyerek_k$)\\
	 Soron következő lépésünk ahhoz az álláshoz vezet, ahonnan a gyökérhez felkerült a legnagyobb érték.
	 
	 \subsection{Átlagoló kiértékelés}
	 Célja a kiértékelő függvény esetleges tévedéseinek simítása.\\
	 MAX szintjeire az m darab legnagyobb értékű gyerek ($max_m$) átlaga, a MIN-re az n darab legkisebb értékű gyerek ($min_n$) átlaga kerül.
	 
	 \subsection{Váltakozó mélységű kiértékelés}
	 Célja, hogy a kiértékelő függvény minden ágon reális értéket mutasson. Megtévesztő lehet egy csúcsnál ez az érték ha annak szülőjénél a kiértékelő függvény lényegesen eltérő értéket mutat: a játék ezen szakasza nincs nyugalomban.\\
	 Egy adott szintig (minimális mélység) mindenképpen felépítjük a részfát,\\
	 majd ettől a szinttől kezdve egy adott szintig (maximális mélység) csak azon csúcsokat terjesztjük ki, amelyekre nem teljesül a nyugalmi teszt: \\
	 $|$f(szülő) - f(csúcs) $|$ $<$K,
	 
	 \subsection{Szelektív kiértékelés}
	 Célja a memória-igény csökkentése.\\
	 Elkülönítjük a lényeges és lényegtelen lépéseket, és csak a lényeges lépéseknek megfelelő részfát építjük fel.\\
	 Ez a szétválasztás heurisztikus ismeretekre épül.\\
	 
	 \newpage
	 \subsection{Negamax algoritmus}
	 Negamax ejárást könnyebb implementálni.\\
	 Kezdetben (-1)-gyel szorozzuk azon levélcsúcsok értékeit, amelyek az ellenfél (MIN) szintjein vannak, majd\\
	 Az értékek felfuttatásánál minden szinten az alábbi módon számoljuk a belső csúcsok értékeit:\\
	 szülő := max(-$gyerek_1$,...,-$gyerek_k$)
	 
	 \subsection{Alfa-béta algoritmus}
	 Visszalépéses algoritmus segítségével járjuk be a részfát (olyan mélységi bejárás, amely mindig csak egy utat tárol). Az aktuális úton fekvő csúcsok ideiglenes értékei:\\
	 - a MAX szintjein $\alpha$ érték: ennél rosszabb értékű állásba innen már nem juthatunk\\
	 - a MIN szintejin $\beta$ érték: ennél jobb értékű állásba onnan már nem juthatunk\\
	 Lefelé haladva a fában $\alpha$:=-$\infty$, és $\beta$:=+$\infty$\\
	 Visszalépéskor az éppen elhagyott (gyermek) csúcs értéke (felhozott érték) módosíthatja a szülő csúcs értékét:\\
	 - a MAX szintjein: $\alpha$ := max(felhozott érték, $\alpha$)\\
	 - a MIN szintjein: $\beta$ := min(felhozott érték, $\beta$)\\
	 Vágás: ha az úton van olyan $\alpha$ és $\beta$, hogy $\alpha$ $\geq$ $\beta$.
	 
	 \subsection{Elemzés}
	 Ugyanazt a kezdőlépést kapjuk eredményül, amit a minimax algoritmus talál. (Több egyforma kezdőirány esetén a "baloldalit" választjuk.)\\
	 Memória igény: csak egy utat tárol.\\
	 Futási idő: a vágások miatt sokkal jobb, mint a minimax módszeré.\\
	 Átlagos eset: egy csúcs alatt, két belőle kiinduló ág megvizsgálása után már vághatunk.\\
	 Optimális eset: egy d mélységű b elágazású fában kiértékelt levélcsúcsok száma: $\sqrt{b\textsuperscript{d}}$\\
	 Jó eset: A részfa megfelelő rendezésével érhető el.
	 
	 \subsection{Kétszemélyes játékot játszó program}
	 Váltakozó mélységű, szelektív, (m,n) átlagoló, negamax alfa-béta kiértékelést végez.\\
	 Keretprogram, amely váltakozva fogadja a felhasználó lépéseit, és generálja a számítógép lépéseit.\\
	 Kiegészítő funkciók (beállítások, útmutató, segítség, korábbi lépések tárolása, mentés stb.)\\
	 Felhasználói felület, grafika\\
	 Heurisztika megválasztása (kiértékelő függvény, szelekció, kiértékelés sorrendje)\\
	 
	 
	
		
\end{document}



